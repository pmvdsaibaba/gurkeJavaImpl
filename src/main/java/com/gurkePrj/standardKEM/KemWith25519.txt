package com.myproject.standardKEM;

import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.crypto.*;
import org.bouncycastle.crypto.agreement.X25519Agreement;
import org.bouncycastle.crypto.params.*;
import org.bouncycastle.util.encoders.Base64;

import java.security.*;
import java.security.interfaces.*;
import java.security.spec.*;
import org.bouncycastle.crypto.generators.X25519KeyPairGenerator;
import org.bouncycastle.crypto.params.X25519KeyGenerationParameters;
import org.bouncycastle.crypto.AsymmetricCipherKeyPair;

public class KEM {

    static {
        // Add Bouncy Castle as a Security Provider
        Security.addProvider(new BouncyCastleProvider());
    }

    // This method generates an X25519 key pair (public and private keys) using BouncyCastle
    public static KeyPair gen() throws NoSuchAlgorithmException, NoSuchProviderException {
        // Create a SecureRandom instance
        SecureRandom random = new SecureRandom();

        // Initialize the X25519 key pair generator
        X25519KeyPairGenerator keyPairGenerator = new X25519KeyPairGenerator();

        // Initialize with X25519 parameters (SecureRandom instance)
        X25519KeyGenerationParameters params = new X25519KeyGenerationParameters(random);
        keyPairGenerator.init(params);

        // Generate the key pair
        AsymmetricCipherKeyPair keyPair = keyPairGenerator.generateKeyPair();
        
        // Extract the public and private keys from the key pair
        X25519PublicKeyParameters publicKeyParameters = (X25519PublicKeyParameters) keyPair.getPublic();
        X25519PrivateKeyParameters privateKeyParameters = (X25519PrivateKeyParameters) keyPair.getPrivate();

        // Convert the keys to byte arrays (encoded format)
        byte[] publicKeyBytes = publicKeyParameters.getEncoded();
        byte[] privateKeyBytes = privateKeyParameters.getEncoded();

        return new KeyPair(publicKeyBytes, privateKeyBytes);
    }

    // KeyPair class to hold the encapsulation key and decapsulation key
    public static class KeyPair {
        private byte[] publicKey; // Store the public key as a byte array
        private byte[] privateKey; // Store the private key as a byte array

        public KeyPair(byte[] ek, byte[] dk) {
            this.publicKey = ek;
            this.privateKey = dk;
        }

        public byte[] getEk() {
            return publicKey;
        }

        public byte[] getDk() {
            return privateKey;
        }
    }

    // This method generates an X25519 key pair based on the provided seed (for deterministic generation)
    public static KeyPair gen(byte[] seed) throws NoSuchAlgorithmException, NoSuchProviderException {
        // Initialize the SecureRandom instance with the provided seed
        SecureRandom random = new SecureRandom(seed);

        // Initialize the X25519 key pair generator
        X25519KeyPairGenerator keyPairGenerator = new X25519KeyPairGenerator();

        // Initialize with X25519 parameters (using the seeded SecureRandom instance)
        X25519KeyGenerationParameters params = new X25519KeyGenerationParameters(random);
        keyPairGenerator.init(params);

        // Generate the key pair
        AsymmetricCipherKeyPair keyPair = keyPairGenerator.generateKeyPair();

        // Extract the public and private keys from the key pair
        X25519PublicKeyParameters publicKeyParameters = (X25519PublicKeyParameters) keyPair.getPublic();
        X25519PrivateKeyParameters privateKeyParameters = (X25519PrivateKeyParameters) keyPair.getPrivate();

        // Convert the keys to byte arrays (encoded format)
        byte[] publicKeyBytes = publicKeyParameters.getEncoded();
        byte[] privateKeyBytes = privateKeyParameters.getEncoded();

        // Return the key pair (with public and private keys as byte arrays)
        return new KeyPair(publicKeyBytes, privateKeyBytes);
    }

    // This method simulates the enc function to generate a key and ciphertext
    public static EncapsulationResult enc(byte[] ek) throws Exception {
        // Convert the byte array to an X25519 public key
        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(ek);
        KeyFactory keyFactory = KeyFactory.getInstance("X25519", "BC");
        X25519PublicKeyParameters publicKey = new X25519PublicKeyParameters(keySpec.getEncoded(), 0);

        // Generate a random shared secret
        SecureRandom secureRandom = new SecureRandom();
        byte[] secretKey = new byte[32]; // Shared secret key (this would typically be derived securely)
        secureRandom.nextBytes(secretKey);

        // Generate private key for encapsulation (X25519)
        X25519PrivateKeyParameters privateKey = new X25519PrivateKeyParameters(secretKey, 0);

        // Use X25519Agreement to perform the key agreement
        X25519Agreement agreement = new X25519Agreement();
        agreement.init(privateKey);

        byte[] ciphertext = new byte[agreement.getAgreementSize()];
        agreement.calculateAgreement(publicKey, ciphertext, 0);

        // Return the result as an EncapsulationResult object containing both the original and encrypted keys
        return new EncapsulationResult(secretKey, ciphertext);
    }

    // EncapsulationResult class to hold key and ciphertext
    public static class EncapsulationResult {
        byte[] k;
        byte[] c;

        public EncapsulationResult(byte[] k, byte[] c) {
            this.k = k;
            this.c = c;
        }

        public byte[] getK() {
            return k;
        }

        public byte[] getC() {
            return c;
        }
    }

    // This method simulates the dec function to generate a key and ciphertext
    public static DecapsulationResult dec(byte[] dk, byte[] c) throws Exception {
        // Convert the byte array to an X25519 private key
        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(dk);
        KeyFactory keyFactory = KeyFactory.getInstance("X25519", "BC");
        X25519PrivateKeyParameters privateKey = new X25519PrivateKeyParameters(keySpec.getEncoded(), 0);

        // Use X25519Agreement to perform the key agreement
        X25519Agreement agreement = new X25519Agreement();
        agreement.init(privateKey);

        byte[] decryptedKey = new byte[agreement.getAgreementSize()];
        agreement.calculateAgreement(new X25519PublicKeyParameters(c, 0), decryptedKey, 0);

        // Return the result as a DecapsulationResult containing the decrypted shared key
        return new DecapsulationResult(decryptedKey);
    }

    // DecapsulationResult class to hold key and ciphertext
    public static class DecapsulationResult {
        byte[] k;

        public DecapsulationResult(byte[] k) {
            this.k = k;
        }

        public byte[] getK() {
            return k;
        }
    }

}
