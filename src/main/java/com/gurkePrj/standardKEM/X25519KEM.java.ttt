import com.gitlab.sodium.NaCl;
import com.gitlab.sodium.crypto.kx.KeyPair;
import com.gitlab.sodium.crypto.kx.Kx;
import com.gitlab.sodium.crypto.kx.Seed;
import com.gitlab.sodium.utils.ByteUtils;
import java.security.SecureRandom;

public class X25519KEM {
    
    static {
        // Ensure Libsodium is initialized
        NaCl.sodium();
    }

    // Key generation (deterministic with a seed)
    public static KeyPair gen(byte[] seed) {
        // Generate key pair deterministically from seed
        return Kx.keyPairFromSeed(seed);
    }

    // Key encapsulation (sender encrypts shared secret using recipient's public key)
    public static byte[] enc(KeyPair senderKeyPair, byte[] recipientPublicKey) {
        // Encrypt the shared secret using recipient's public key
        byte[] sharedSecret = Kx.sharedSecret(senderKeyPair.getPrivateKey(), recipientPublicKey);
        
        // Optionally, add ephemeral data like a nonce
        SecureRandom random = new SecureRandom();
        byte[] nonce = new byte[24];  // Example nonce size
        random.nextBytes(nonce);
        
        // Combine shared secret with nonce for encapsulation
        byte[] encapsulated = new byte[sharedSecret.length + nonce.length];
        System.arraycopy(sharedSecret, 0, encapsulated, 0, sharedSecret.length);
        System.arraycopy(nonce, 0, encapsulated, sharedSecret.length, nonce.length);

        return encapsulated;
    }

    // Key decapsulation (recipient decrypts the shared secret using their private key)
    public static byte[] dec(KeyPair recipientKeyPair, byte[] encapsulatedKey) {
        // Extract shared secret from encapsulated key
        byte[] sharedSecret = new byte[32];  // Shared secret size for X25519
        byte[] nonce = new byte[24];  // Example nonce size
        
        System.arraycopy(encapsulatedKey, 0, sharedSecret, 0, 32);
        System.arraycopy(encapsulatedKey, 32, nonce, 0, nonce.length);
        
        // Decrypt shared secret using recipient's private key
        return Kx.sharedSecret(recipientKeyPair.getPrivateKey(), sharedSecret);
    }

    // Helper method to convert byte array to hex string (for visualization)
    public static String bytesToHex(byte[] bytes) {
        StringBuilder hexString = new StringBuilder();
        for (byte b : bytes) {
            hexString.append(String.format("%02x", b));
        }
        return hexString.toString();
    }

    // Test the Key Generation, Encapsulation, and Decapsulation
    public static void main(String[] args) {
        try {
            // Generate deterministic seed (using a fixed value)
            byte[] seed = "a-fixed-deterministic-seed".getBytes();

            // 1. Key Generation (sender and receiver)
            KeyPair senderKeyPair = gen(seed);  // Sender uses a fixed deterministic seed
            KeyPair receiverKeyPair = gen("another-fixed-seed".getBytes());  // Receiver uses another fixed deterministic seed
            
            System.out.println("Sender's Private Key: " + bytesToHex(senderKeyPair.getPrivateKey()));
            System.out.println("Sender's Public Key: " + bytesToHex(senderKeyPair.getPublicKey()));

            System.out.println("Receiver's Private Key: " + bytesToHex(receiverKeyPair.getPrivateKey()));
            System.out.println("Receiver's Public Key: " + bytesToHex(receiverKeyPair.getPublicKey()));

            // 2. Key Encapsulation (sender encapsulates key)
            byte[] encapsulatedKey = enc(senderKeyPair, receiverKeyPair.getPublicKey());
            System.out.println("Encapsulated Key: " + bytesToHex(encapsulatedKey));

            // 3. Key Decapsulation (receiver decapsulates key)
            byte[] decapsulatedSharedSecret = dec(receiverKeyPair, encapsulatedKey);
            System.out.println("Decapsulated Shared Secret: " + bytesToHex(decapsulatedSharedSecret));

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
