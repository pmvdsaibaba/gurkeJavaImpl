// package com.gurkePrj.nikeex

import java.security.*;
import javax.crypto.*;
import java.security.interfaces.*;
import java.security.spec.*;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

public class NIKEexample {

    // NIKE Algorithm definition
    // N.gen : SK → PK, generates a public key from a secret key
    // N.key : SK × PK → K, derives a shared key from a secret key and a public key

    public static void main(String[] args) throws Exception {
        Security.addProvider(new BouncyCastleProvider());

        // 1. Key Generation (N.gen)
        byte[] secretKey = new byte[32]; // 256-bit secret key for example
        SecureRandom secureRandom = new SecureRandom();
        secureRandom.nextBytes(secretKey);

        KeyPair keyPair = gen(secretKey);

        // Print generated keys
        System.out.println("Public Key: " + bytesToHex(keyPair.getPublicKey()));
        System.out.println("Private Key: " + bytesToHex(keyPair.getPrivateKey()));

        // 2. Key Exchange (N.key)
        byte[] sharedKey = keyExchange(secretKey, keyPair.getPublicKey());

        // Print the shared symmetric key
        System.out.println("Shared Key: " + bytesToHex(sharedKey));
    }

    // N.gen : SK → PK, generates a public key from a secret key (private key)
    public static KeyPair gen(byte[] secretKey) throws Exception {
        // Generate public/private key pair based on a secret key
        // For simplicity, we use RSA (though in real-world use, other cryptographic methods could be used)
        
        // Add Bouncy Castle as a Security Provider
        Security.addProvider(new BouncyCastleProvider());
        // 1. Generate RSA Key Pair
        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC");
        keyPairGenerator.initialize(2048); // 2048-bit RSA keys
        java.security.KeyPair keyPair = keyPairGenerator.generateKeyPair();

        // Return KeyPair (encapsulation key and decapsulation key)
        return new KeyPair(keyPair.getPublic().getEncoded(), keyPair.getPrivate().getEncoded());
    }

    // N.key : SK × PK → K, derive a shared key from a secret key and a public key
    public static byte[] keyExchange(byte[] secretKey, byte[] publicKeyBytes) throws Exception {
        // Convert the public key bytes into a RSAPublicKey object
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicKeyBytes);
        RSAPublicKey publicKey = (RSAPublicKey) keyFactory.generatePublic(keySpec);

        // Perform Diffie-Hellman or a similar exchange mechanism here to derive a shared key
        // For the sake of simplicity, we'll use a random secret key directly as the shared key.
        
        // In practice, you would use a secure key exchange mechanism like ECDH, DH, or RSA-based KEM
        Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding", "BC");
        cipher.init(Cipher.ENCRYPT_MODE, publicKey);

        // Simulating the shared secret key with some random bytes (for demonstration purposes)
        byte[] sharedKey = new byte[32]; // 256-bit shared key
        new SecureRandom().nextBytes(sharedKey);

        return sharedKey;
    }

    // KeyPair class to hold public and private keys
    public static class KeyPair {
        private byte[] publicKey;  // Public Key
        private byte[] privateKey; // Private Key

        // Constructor to initialize KeyPair with public and private keys
        public KeyPair(byte[] publicKey, byte[] privateKey) {
            this.publicKey = publicKey;
            this.privateKey = privateKey;
        }

        // Getter methods for keys
        public byte[] getPublicKey() {
            return publicKey;
        }

        public byte[] getPrivateKey() {
            return privateKey;
        }
    }

    // Utility method to convert byte array to Hex string (for display purposes)
    public static String bytesToHex(byte[] bytes) {
        StringBuilder hexString = new StringBuilder();
        for (byte b : bytes) {
            hexString.append(String.format("%02X", b));
        }
        return hexString.toString();
    }
}
