<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UB_KEM.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">gurkeImp</a> &gt; <a href="index.source.html" class="el_package">com.myproject.dynamicUBKem</a> &gt; <span class="el_source">UB_KEM.java</span></div><h1>UB_KEM.java</h1><pre class="source lang-java linenums">package com.myproject.dynamicUBKem;

import com.myproject.Tree.Tree;
import com.myproject.Tree.TreeDk;
import com.myproject.Tree.TreeEK;
import com.myproject.Tree.TreeAddDkReturn;
import com.myproject.Nike.Nike;
import com.myproject.RandomOracle.RandomOracle;
import com.myproject.Tree.TreeGetPathReturn;
import com.myproject.Tree.TreeAddEkReturn;
import com.myproject.Tree.TreeGetNodesReturn;

import java.security.SecureRandom;
import org.bouncycastle.crypto.prng.FixedSecureRandom;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;


<span class="fc" id="L23">public class UB_KEM {</span>


    public static class BKGenResult {
        public TreeEK ek;
        public List&lt;TreeDk&gt; dkList;

<span class="fc" id="L30">        public BKGenResult(TreeEK ek, List&lt;TreeDk&gt; dkList) {</span>
<span class="fc" id="L31">            this.ek = ek;</span>
<span class="fc" id="L32">            this.dkList = dkList;</span>
<span class="fc" id="L33">        }</span>
    }




    public static BKGenResult gen(int n) throws Exception {

<span class="fc" id="L41">        Tree tree = Tree.init(n);</span>

<span class="fc" id="L43">        List&lt;Integer&gt; nodeIndexes = tree.nodes();</span>

<span class="fc" id="L45">        Map&lt;Integer, byte[]&gt; pkMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L46">        Map&lt;Integer, byte[]&gt; skMap = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L48" title="All 2 branches covered.">        for (int j = 0; j &lt; nodeIndexes.size(); j++)</span>
        {
<span class="fc" id="L50">            Nike.KeyPair kp = Nike.gen();</span>

<span class="fc" id="L52">            pkMap.put(j + 1, kp.getEk());</span>
<span class="fc" id="L53">            skMap.put(j + 1, kp.getDk());</span>
        }

<span class="fc" id="L56">        TreeEK ek = tree.setNodes(pkMap);</span>

<span class="fc" id="L58">        List&lt;TreeDk&gt; dkList = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L60" title="All 2 branches covered.">        for (int i = 1; i &lt;= n; i++)</span>
        {
<span class="fc" id="L62">            List&lt;Integer&gt; path = tree.T_path(i);</span>

<span class="fc" id="L64">            Map&lt;Integer, byte[]&gt; pathSkMap = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L66" title="All 2 branches covered.">            for (Integer pathNodeIndex : path) {</span>
<span class="fc" id="L67">                pathSkMap.put(pathNodeIndex, skMap.get(pathNodeIndex));</span>
<span class="fc" id="L68">            }</span>

<span class="fc" id="L70">            TreeDk dk = tree.setPath(i, pathSkMap);</span>
<span class="fc" id="L71">            dkList.add(dk);</span>
        }


<span class="fc" id="L75">        return new BKGenResult(ek, dkList);</span>
    }


    public static class BKEncResult {
        public EncOutput u;
        public byte[] c;

<span class="fc" id="L83">        public BKEncResult(EncOutput u, byte[] c) {</span>
<span class="fc" id="L84">            this.u = u;</span>
<span class="fc" id="L85">            this.c = c;</span>
<span class="fc" id="L86">        }</span>
    }

    public static class EncOutput {
        public TreeEK ek;
        public byte[] sk;
        public byte[] c;

<span class="fc" id="L94">        public EncOutput(TreeEK ek, byte[] sk, byte[] c) {</span>
<span class="fc" id="L95">            this.ek = ek;</span>
<span class="fc" id="L96">            this.sk = sk;</span>
<span class="fc" id="L97">            this.c = c;</span>
<span class="fc" id="L98">        }</span>
    }

    public static  BKEncResult enc(TreeEK ek) throws Exception {

<span class="fc" id="L103">        byte E = (byte) 'E';  // 69</span>

<span class="fc" id="L105">        Nike.KeyPair kp = Nike.gen();</span>

<span class="fc" id="L107">        byte[] pk = kp.getEk();</span>
<span class="fc" id="L108">        byte[] sk = kp.getDk();</span>

        // c ← (E, pk)
<span class="fc" id="L111">        byte[] c = prependByte(E, pk);</span>

<span class="fc" id="L113">        EncOutput u = new EncOutput(ek, sk, c);</span>

<span class="fc" id="L115">        return new BKEncResult(u, c);</span>
    }

    public static byte[] prependByte(byte prefix, byte[] original) {
<span class="fc" id="L119">        byte[] result = new byte[original.length + 1];</span>
<span class="fc" id="L120">        result[0] = prefix; // Set F at the beginning</span>
<span class="fc" id="L121">        System.arraycopy(original, 0, result, 1, original.length);</span>
<span class="fc" id="L122">        return result;</span>
    }

    public static class FinResult {
        public TreeEK ek;
        public byte[] k; // Final derived key

<span class="fc" id="L129">        public FinResult(TreeEK ek, byte[] k) {</span>
<span class="fc" id="L130">            this.ek = ek;</span>
<span class="fc" id="L131">            this.k = k;</span>
<span class="fc" id="L132">        }</span>
    }

    public static FinResult fin(EncOutput u, byte[] ad) throws Exception {
<span class="fc" id="L136">        TreeEK ek = u.ek;</span>
<span class="fc" id="L137">        byte[] sk = u.sk;</span>
<span class="fc" id="L138">        byte[] c = u.c;</span>

<span class="fc" id="L140">        TreeGetNodesReturn getnodesreturn = Tree.getNodes(ek); </span>
<span class="fc" id="L141">        Map&lt;Integer, byte[]&gt; pkMap = getnodesreturn.getDataPk();</span>

<span class="fc" id="L143">        Map&lt;Integer, byte[]&gt; newPkMap = new HashMap&lt;&gt;();</span>

<span class="fc" id="L145">        byte[] kFinal = null;</span>

<span class="fc bfc" id="L147" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, byte[]&gt; entry : pkMap.entrySet()) {</span>
<span class="fc" id="L148">            int nodeId = entry.getKey();</span>
<span class="fc" id="L149">            byte[] pkj = entry.getValue();</span>

<span class="fc" id="L151">            byte[] kPrime = Nike.key(sk, pkj);</span>

<span class="fc" id="L153">            RandomOracle.RandomOracleResult hashOutput = RandomOracle.H(c, kPrime, ad);</span>
<span class="fc" id="L154">            byte[] s = hashOutput.getS();</span>
<span class="fc" id="L155">            byte[] kj = hashOutput.getK();</span>

<span class="fc" id="L157">            Nike.KeyPair newKp = Nike.gen(s);</span>
<span class="fc" id="L158">            byte[] newPk = newKp.getEk();</span>

<span class="fc" id="L160">            newPkMap.put(nodeId, newPk);</span>

<span class="pc bpc" id="L162" title="1 of 4 branches missed.">            if ((kFinal == null) &amp;&amp; ( nodeId == 1 )) </span>
            {
<span class="fc" id="L164">                kFinal = kj;</span>

                // System.out.println(&quot;BK.fin SK:&quot;);
                // printByteArray(sk);
                // System.out.println(&quot;BK.fin PK:&quot;);
                // printByteArray(pkj);
                // System.out.println(&quot;BK.fin  k prime &quot;);
                // printByteArray(kPrime);
            }
<span class="fc" id="L173">        }</span>

<span class="fc" id="L175">        TreeEK newEk = getnodesreturn.getTree().setNodes(newPkMap);</span>

<span class="fc" id="L177">        return new FinResult(newEk, kFinal);</span>
    }

    public static class DecResult {
        public TreeDk dk;
        public byte[] k;

<span class="fc" id="L184">        public DecResult(TreeDk dk, byte[] k) {</span>
<span class="fc" id="L185">            this.dk = dk;</span>
<span class="fc" id="L186">            this.k = k;</span>
<span class="fc" id="L187">        }</span>
    }

    public static DecResult dec(TreeDk dk, byte[] ad, byte[] c) throws Exception {

<span class="fc" id="L192">        TreeGetPathReturn pathResult = Tree.getPath(dk);</span>
<span class="fc" id="L193">        int i = pathResult.getLeafIndex();</span>
<span class="fc" id="L194">        Map&lt;Integer, byte[]&gt; skMap = pathResult.getDataSk();</span>

<span class="fc" id="L196">        byte[] pk = new byte[c.length - 1];</span>
<span class="fc" id="L197">        System.arraycopy(c, 1, pk, 0, pk.length);</span>

<span class="fc" id="L199">        Map&lt;Integer, byte[]&gt; updatedSkMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L200">        byte[] kFinal = null;</span>


        // In tree add and rmv. these pk and sk map should be updated.
        // to do: may be get the tree with valid nodes.
<span class="fc bfc" id="L205" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, byte[]&gt; entry : skMap.entrySet()) {</span>
<span class="fc" id="L206">            int nodeId = entry.getKey();</span>
<span class="fc" id="L207">            byte[] skl = entry.getValue();</span>

<span class="fc" id="L209">            byte[] kPrime = Nike.key(skl, pk);</span>

<span class="fc" id="L211">            RandomOracle.RandomOracleResult hashOutput = RandomOracle.H(c, kPrime, ad);</span>
<span class="fc" id="L212">            byte[] s = hashOutput.getS();</span>
<span class="fc" id="L213">            byte[] kl = hashOutput.getK();</span>

<span class="fc" id="L215">            Nike.KeyPair newKp = Nike.gen(s);</span>
<span class="fc" id="L216">            byte[] newSk = newKp.getDk();</span>

<span class="fc" id="L218">            updatedSkMap.put(nodeId, newSk);</span>

<span class="fc bfc" id="L220" title="All 4 branches covered.">            if ((kFinal == null) &amp;&amp; ( nodeId == 1 ))</span>
            {
<span class="fc" id="L222">                kFinal = kl;</span>

                // System.out.println(&quot;BK.dec SK:&quot;);
                // printByteArray(skl);
                // System.out.println(&quot;BK.dec PK:&quot;);
                // printByteArray(pk);
                // System.out.println(&quot;BK.dec  k prime &quot;);
                // printByteArray(kPrime);
            }

            // kFinal = kl;
<span class="fc" id="L233">        }</span>

<span class="fc" id="L235">        TreeDk newDk = pathResult.getTree().setPath(i, updatedSkMap);</span>

<span class="fc" id="L237">        return new DecResult(newDk, kFinal); // Step 43: Return (dk, k)</span>
    }

    public static class BKAddResult {
        public TreeEK ek;
        public TreeDk dk;
        public c_BKAdd c;

<span class="fc" id="L245">        public BKAddResult(TreeEK ek, TreeDk dk, c_BKAdd c) {</span>
<span class="fc" id="L246">            this.ek = ek;</span>
<span class="fc" id="L247">            this.dk = dk;</span>
<span class="fc" id="L248">            this.c = c;</span>
<span class="fc" id="L249">        }</span>
    }

    public static class c_BKAdd {
        public byte t;
        public Map&lt;Integer, byte[]&gt; pkstarMap;
        public Map&lt;Integer, byte[]&gt; pk_lMap;

<span class="fc" id="L257">        public c_BKAdd(byte t, Map&lt;Integer, byte[]&gt; pkstarMap, Map&lt;Integer, byte[]&gt; pk_lMap) {</span>
<span class="fc" id="L258">            this.t = t;</span>
<span class="fc" id="L259">            this.pkstarMap = pkstarMap;</span>
<span class="fc" id="L260">            this.pk_lMap = pk_lMap;</span>
<span class="fc" id="L261">        }</span>
    }

    public static BKAddResult add(TreeEK ek) throws Exception {

<span class="fc" id="L266">        TreeAddEkReturn addReturn = Tree.T_add_Ek(ek);</span>
        // Map&lt;Integer, byte[]&gt; pkMap = addReturn.getDataPk();

<span class="fc" id="L269">        Map&lt;Integer, byte[]&gt; originalMap = addReturn.getDataPk();</span>
<span class="fc" id="L270">        Map&lt;Integer, byte[]&gt; pkMap = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L272" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, byte[]&gt; entry : originalMap.entrySet()) {</span>
<span class="fc" id="L273">            pkMap.put(entry.getKey(), Arrays.copyOf(entry.getValue(), entry.getValue().length));</span>
<span class="fc" id="L274">        }</span>

<span class="fc" id="L276">        List&lt;Integer&gt; path = addReturn.getPathList(); </span>
<span class="fc" id="L277">        List&lt;Integer&gt; coPath = addReturn.getCoPathList(); </span>
<span class="fc" id="L278">        int n = addReturn.getLeafsCount();</span>
<span class="fc" id="L279">        Tree tempTree = addReturn.getTree();</span>

        // pk*
<span class="fc" id="L282">        Map&lt;Integer, byte[]&gt; pkStarMap =  new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L284" title="All 2 branches covered.">        for (Integer pathNodeIndex : coPath) {</span>
<span class="fc" id="L285">            pkStarMap.put(pathNodeIndex, pkMap.get(pathNodeIndex));</span>
<span class="fc" id="L286">        }</span>

<span class="fc" id="L288">        Nike.KeyPair leafKeyPair = Nike.gen();</span>
<span class="fc" id="L289">        byte[] sk = leafKeyPair.getDk();</span>
<span class="fc" id="L290">        byte[] pk = leafKeyPair.getEk();</span>

<span class="fc" id="L292">        Map&lt;Integer, byte[]&gt; pkNewMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L293">        Map&lt;Integer, byte[]&gt; skNewMap = new HashMap&lt;&gt;();</span>

<span class="fc" id="L295">        skNewMap.put(path.get(0), sk);</span>
<span class="fc" id="L296">        pkMap.put(path.get(0), pk);</span>

<span class="fc" id="L298">        byte[] seed = new byte[32]; // 256-bit seed</span>
<span class="fc" id="L299">        Arrays.fill(seed, (byte) 0xAC); // Fill with 0xEF</span>

        // FixedSecureRandom secureRandom = new FixedSecureRandom(seed); 
<span class="fc" id="L302">        SecureRandom secureRandom = new SecureRandom();</span>
<span class="fc" id="L303">        byte[] sPrime = new byte[32];</span>
<span class="fc" id="L304">        secureRandom.nextBytes(sPrime);</span>



<span class="fc bfc" id="L308" title="All 2 branches covered.">        for (int l = 0; l &lt; (path.size() - 1);  l++) {</span>
<span class="fc" id="L309">            Nike.KeyPair kp = Nike.gen(sPrime);</span>
<span class="fc" id="L310">            byte[] pk_l = kp.getEk();</span>
<span class="fc" id="L311">            byte[] sk_l = kp.getDk();</span>

<span class="fc" id="L313">            pkNewMap.put(path.get(l), pk_l);</span>

<span class="fc" id="L315">            byte[] k = Nike.key(sk_l, pkMap.get(coPath.get(l)));</span>

<span class="fc" id="L317">            RandomOracle.RandomOracleResult roRes = RandomOracle.H(k, pk_l);</span>
<span class="fc" id="L318">            byte[] s = roRes.getS();</span>
<span class="fc" id="L319">            sPrime = roRes.getK(); // updated s′</span>

<span class="fc" id="L321">            Nike.KeyPair kpPrev = Nike.gen(s);</span>
<span class="fc" id="L322">            byte[] pkPrev = kpPrev.getEk();</span>
<span class="fc" id="L323">            byte[] skPrev = kpPrev.getDk();</span>

<span class="fc" id="L325">            pkMap.put(path.get(l+1), pkPrev);</span>
<span class="fc" id="L326">            skNewMap.put(path.get(l+1), skPrev);</span>
        }

<span class="fc" id="L329">        TreeEK newEk = tempTree.setNodes(pkMap);</span>

        // here n is not the num of leaves but the added latest leaf index
<span class="fc" id="L332">        TreeDk newDk = tempTree.setPath(n, skNewMap);</span>

<span class="fc" id="L334">        byte A = (byte) 'A';</span>
<span class="fc" id="L335">        c_BKAdd c = new c_BKAdd(A, pkStarMap, pkNewMap);</span>

<span class="fc" id="L337">        return new BKAddResult(newEk, newDk, c);</span>
    }

    public static class BKRemoveResult {
        public TreeEK ek;
        public c_BKRemove c;

<span class="fc" id="L344">        public BKRemoveResult(TreeEK ek, c_BKRemove c) {</span>
<span class="fc" id="L345">            this.ek = ek;</span>
<span class="fc" id="L346">            this.c = c;</span>
<span class="fc" id="L347">        }</span>
    }

    public static class c_BKRemove {
        public byte t;
        public int i;
        public Map&lt;Integer, byte[]&gt; pkStarMap;
        public byte[] pkCircle;
        public Map&lt;Integer, byte[]&gt; pkPrimeMap;

<span class="fc" id="L357">        public c_BKRemove(byte t, int i, Map&lt;Integer, byte[]&gt; pkStarMap, byte[] pkCircle, Map&lt;Integer, byte[]&gt; pkPrimeMap) {</span>
<span class="fc" id="L358">            this.t = t;</span>
<span class="fc" id="L359">            this.i = i;</span>
<span class="fc" id="L360">            this.pkStarMap = pkStarMap;</span>
<span class="fc" id="L361">            this.pkCircle = pkCircle;</span>
<span class="fc" id="L362">            this.pkPrimeMap = pkPrimeMap;</span>
<span class="fc" id="L363">        }</span>
    }

    public static BKRemoveResult rmv(TreeEK ek, int i) throws Exception
    {
<span class="fc" id="L368">        TreeAddEkReturn remReturn = Tree.T_rem_Ek(ek, i);</span>

        // Map&lt;Integer, byte[]&gt; pkMap = remReturn.getDataPk();

<span class="fc" id="L372">        Map&lt;Integer, byte[]&gt; originalMap = remReturn.getDataPk();</span>
<span class="fc" id="L373">        Map&lt;Integer, byte[]&gt; pkMap = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L375" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, byte[]&gt; entry : originalMap.entrySet()) {</span>
<span class="fc" id="L376">            pkMap.put(entry.getKey(), Arrays.copyOf(entry.getValue(), entry.getValue().length));</span>
<span class="fc" id="L377">        }</span>

<span class="fc" id="L379">        List&lt;Integer&gt; path = remReturn.getPathList();</span>
<span class="fc" id="L380">        List&lt;Integer&gt; coPath = remReturn.getCoPathList();     // (cpl)</span>
<span class="fc" id="L381">        Tree tempTree = remReturn.getTree();</span>

<span class="fc" id="L383">        Map&lt;Integer, byte[]&gt; pkStarMap = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L385" title="All 2 branches covered.">        for (Integer coPathNode : coPath) {</span>
<span class="fc" id="L386">            pkStarMap.put(coPathNode, pkMap.get(coPathNode));</span>
<span class="fc" id="L387">        }</span>

<span class="fc" id="L389">        Nike.KeyPair kpCircle = Nike.gen();</span>
<span class="fc" id="L390">        byte[] pkCircle = kpCircle.getEk();</span>
<span class="fc" id="L391">        byte[] skCircle = kpCircle.getDk();</span>

<span class="fc" id="L393">        byte[] pkpL = pkMap.get(path.get(0));</span>
<span class="fc" id="L394">        byte[] k = Nike.key(skCircle, pkpL);</span>

<span class="fc" id="L396">        RandomOracle.RandomOracleResult ro1 = RandomOracle.H(k, pkCircle);</span>
<span class="fc" id="L397">        byte[] s = ro1.getS();</span>
<span class="fc" id="L398">        byte[] sPrime = ro1.getK();</span>

<span class="fc" id="L400">        Nike.KeyPair kpPL = Nike.gen(s);</span>
<span class="fc" id="L401">        byte[] newPkpL = kpPL.getEk();</span>
<span class="fc" id="L402">        pkMap.put(path.get(0), newPkpL);</span>

<span class="fc" id="L404">        Map&lt;Integer, byte[]&gt; pkPrimeMap = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L406" title="All 2 branches covered.">        for (int l = 0; l &lt; (path.size() - 1);  l++) </span>
        {
<span class="fc" id="L408">            Nike.KeyPair kpPrimeL = Nike.gen(sPrime);</span>
<span class="fc" id="L409">            byte[] pkPrimeL = kpPrimeL.getEk();</span>
<span class="fc" id="L410">            byte[] skPrimeL = kpPrimeL.getDk();</span>
<span class="fc" id="L411">            pkPrimeMap.put(path.get(l), pkPrimeL);</span>

<span class="fc" id="L413">            byte[] pkCoPath = pkMap.get(coPath.get(l));</span>
<span class="fc" id="L414">            k = Nike.key(skPrimeL, pkCoPath);</span>

<span class="fc" id="L416">            RandomOracle.RandomOracleResult ro2 = RandomOracle.H(k, pkPrimeL);</span>
<span class="fc" id="L417">            s = ro2.getS();</span>
<span class="fc" id="L418">            sPrime = ro2.getK();</span>

<span class="fc" id="L420">            Nike.KeyPair kpParent = Nike.gen(s);</span>
<span class="fc" id="L421">            byte[] pkParent = kpParent.getEk();</span>
<span class="fc" id="L422">            pkMap.put(path.get(l + 1), pkParent);</span>
        }

<span class="fc" id="L425">        TreeEK newEk = tempTree.setNodes(pkMap);</span>

<span class="fc" id="L427">        byte R = (byte) 'R';</span>
<span class="fc" id="L428">        c_BKRemove c = new c_BKRemove(R, i, pkStarMap, pkCircle, pkPrimeMap);</span>

<span class="fc" id="L430">        return new BKRemoveResult(newEk, c);</span>
    }

    public static class BKForkResult {
        public TreeEK ek1;
        public TreeEK ek2;
        public c_BKFork c;

<span class="fc" id="L438">        public BKForkResult(TreeEK ek1, TreeEK ek2, c_BKFork c) {</span>
<span class="fc" id="L439">            this.ek1 = ek1;</span>
<span class="fc" id="L440">            this.ek2 = ek2;</span>
<span class="fc" id="L441">            this.c = c;</span>
<span class="fc" id="L442">        }</span>
    }

    public static class c_BKFork {
        public byte t;
        public byte[] pk;

<span class="fc" id="L449">        public c_BKFork(byte t, byte[] pk) {</span>
<span class="fc" id="L450">            this.t = t;</span>
<span class="fc" id="L451">            this.pk = pk;</span>
<span class="fc" id="L452">        }</span>
    }

    public static BKForkResult fork(TreeEK ek) throws Exception
    {
<span class="fc" id="L457">        Nike.KeyPair forkKp = Nike.gen();</span>
<span class="fc" id="L458">        byte[] pkFork = forkKp.getEk();</span>
<span class="fc" id="L459">        byte[] skFork = forkKp.getDk();</span>

<span class="fc" id="L461">        byte F = (byte) 'F';</span>
<span class="fc" id="L462">        byte[] c = prependByte(F, pkFork);</span>

<span class="fc" id="L464">        TreeGetNodesReturn getnodesreturn = Tree.getNodes(ek);</span>
<span class="fc" id="L465">        Map&lt;Integer, byte[]&gt; pkMap = getnodesreturn.getDataPk();</span>
<span class="fc" id="L466">        Tree Tree1 = getnodesreturn.getTree();</span>


<span class="fc" id="L469">        Map&lt;Integer, byte[]&gt; pk1Map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L470">        Map&lt;Integer, byte[]&gt; pk2Map = new HashMap&lt;&gt;();</span>

        // In tree add and rmv. these pk and sk map should be updated.
        // to do: may be get the tree with valid nodes. 
        // update: this seems ok for now
<span class="fc bfc" id="L475" title="All 2 branches covered.">        for (Map.Entry&lt;Integer, byte[]&gt; entry : pkMap.entrySet()) {</span>
<span class="fc" id="L476">            int nodeId = entry.getKey();</span>
<span class="fc" id="L477">            byte[] pkj = entry.getValue();</span>

<span class="fc" id="L479">            byte[] k = Nike.key(skFork, pkj);</span>

            // H(k, c, 1)
<span class="fc" id="L482">            RandomOracle.RandomOracleResult ro1 = RandomOracle.H(c, k, new byte[]{1});</span>
<span class="fc" id="L483">            byte[] s1j = ro1.getS();</span>

            // H(k, c, 2)
<span class="fc" id="L486">            RandomOracle.RandomOracleResult ro2 = RandomOracle.H(c, k, new byte[]{2});</span>
<span class="fc" id="L487">            byte[] s2j = ro2.getS();</span>

<span class="fc" id="L489">            Nike.KeyPair kp1j = Nike.gen(s1j);</span>
<span class="fc" id="L490">            Nike.KeyPair kp2j = Nike.gen(s2j);</span>

<span class="fc" id="L492">            pk1Map.put(nodeId, kp1j.getEk());</span>
<span class="fc" id="L493">            pk2Map.put(nodeId, kp2j.getEk());</span>
<span class="fc" id="L494">        }</span>

<span class="fc" id="L496">        TreeEK ek1 = Tree1.setNodes(pk1Map);</span>
<span class="fc" id="L497">        TreeEK ek2 = Tree1.setNodes(pk2Map);</span>

<span class="fc" id="L499">        return new BKForkResult(ek1, ek2, new c_BKFork(F, pkFork));</span>
    }

    public static class BKProcResult {
        public TreeDk dk1;
        public TreeDk dk2;

<span class="fc" id="L506">        public BKProcResult(TreeDk dk1, TreeDk dk2) {</span>
<span class="fc" id="L507">            this.dk1 = dk1;</span>
<span class="fc" id="L508">            this.dk2 = dk2;</span>
<span class="fc" id="L509">        }</span>
    }

    public static BKProcResult proc(TreeDk dk, Object c) throws Exception
    {
        byte t;
        Object cPrime;

        // List&lt;Integer&gt; set2 = new ArrayList&lt;&gt;(dk.getDataSk().keySet());
        // int leafNodeIndex = Tree.findLeafIndexFromSet(set2, dk.getTree());
        // List&lt;Integer&gt; dkPath = dk.getTree().T_path(leafNodeIndex);

<span class="fc bfc" id="L521" title="All 2 branches covered.">        if (c instanceof c_BKFork)</span>
        {
<span class="fc" id="L523">            c_BKFork fork = (c_BKFork) c;</span>
<span class="fc" id="L524">            t = fork.t;</span>
<span class="fc" id="L525">            cPrime = fork.pk;</span>

<span class="fc" id="L527">            TreeGetPathReturn pathResult = Tree.getPath(dk);</span>
<span class="fc" id="L528">            int i = pathResult.getLeafIndex();</span>
<span class="fc" id="L529">            Map&lt;Integer, byte[]&gt; skMap = pathResult.getDataSk();</span>

<span class="fc" id="L531">            Map&lt;Integer, byte[]&gt; sk1Map = new HashMap&lt;&gt;();</span>
<span class="fc" id="L532">            Map&lt;Integer, byte[]&gt; sk2Map = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L534" title="All 2 branches covered.">            for (Map.Entry&lt;Integer, byte[]&gt; entry : skMap.entrySet())</span>
            {
<span class="fc" id="L536">                int nodeId = entry.getKey();</span>
<span class="fc" id="L537">                byte[] skl = entry.getValue();</span>

<span class="fc" id="L539">                byte[] k = Nike.key(skl, (byte[]) cPrime);</span>

<span class="fc" id="L541">                byte[] cRaw = prependByte(t, (byte[]) cPrime);</span>
<span class="fc" id="L542">                byte[] tag1 = new byte[]{1};</span>
<span class="fc" id="L543">                byte[] tag2 = new byte[]{2};</span>

<span class="fc" id="L545">                byte[] s1l = RandomOracle.H(cRaw, k, tag1).getS();</span>
<span class="fc" id="L546">                byte[] s2l = RandomOracle.H(cRaw, k, tag2).getS();</span>

<span class="fc" id="L548">                byte[] sk1l = Nike.gen(s1l).getDk();</span>
<span class="fc" id="L549">                byte[] sk2l = Nike.gen(s2l).getDk();</span>

<span class="fc" id="L551">                sk1Map.put(nodeId, sk1l);</span>
<span class="fc" id="L552">                sk2Map.put(nodeId, sk2l);</span>
<span class="fc" id="L553">            }</span>

<span class="fc" id="L555">            TreeDk dk1 = pathResult.getTree().setPath(i, sk1Map);</span>
<span class="fc" id="L556">            TreeDk dk2 = pathResult.getTree().setPath(i, sk2Map);</span>
<span class="fc" id="L557">            return new BKProcResult(dk1, dk2);</span>
        } 
<span class="pc bpc" id="L559" title="1 of 4 branches missed.">        else if (c instanceof c_BKAdd || c instanceof c_BKRemove)</span>
        {
            TreeDk newDk;
            Tree tree;
            // Tree treeOldDk;
            int i;
            Map&lt;Integer, byte[]&gt; skMap;
            int lStar;

<span class="fc bfc" id="L568" title="All 2 branches covered.">            if (c instanceof c_BKAdd)</span>
            {
<span class="fc" id="L570">                c_BKAdd add = (c_BKAdd) c;</span>
<span class="fc" id="L571">                t = add.t;</span>
<span class="fc" id="L572">                cPrime = new Object[]{add.pk_lMap, add.pkstarMap};</span>

<span class="fc" id="L574">                TreeAddDkReturn addDk = Tree.T_add_dk(dk);</span>
<span class="fc" id="L575">                tree = addDk.getTree();</span>
                // treeOldDk = addDk.getTree();
<span class="fc" id="L577">                i = addDk.getLeafIndex();</span>
<span class="fc" id="L578">                skMap = addDk.getDataSk();</span>
<span class="fc" id="L579">                lStar = addDk.getLeafIntersectionIndex();</span>
<span class="fc" id="L580">            }</span>
            else
            {
<span class="fc" id="L583">                c_BKRemove rem = (c_BKRemove) c;</span>
<span class="fc" id="L584">                t = rem.t;</span>
<span class="fc" id="L585">                cPrime = new Object[]{rem.i, rem.pkStarMap, rem.pkCircle, rem.pkPrimeMap};</span>

                // printTreeDiagram(dk.getTree());
<span class="fc" id="L588">                TreeAddDkReturn remDk = Tree.T_rem_Dk(dk, rem.i);</span>
                // treeOldDk = dk.getTree();
<span class="fc" id="L590">                tree = remDk.getTree();</span>
                // printTreeDiagram(tree);
<span class="fc" id="L592">                i = remDk.getLeafIndex();</span>
<span class="fc" id="L593">                skMap = remDk.getDataSk();</span>
<span class="fc" id="L594">                lStar = remDk.getLeafIntersectionIndex();</span>
            }



            
            // Get path length
            // List&lt;Integer&gt; path = tree.T_path(i);
            // int position = path.indexOf(lStar);

            List&lt;Integer&gt; path_Pk;
            List&lt;Integer&gt; path_Sk;
            List&lt;Integer&gt; co_path_Sk;
            int position;
            int position_InSk;

            byte[] pkR, skL;
<span class="fc bfc" id="L611" title="All 2 branches covered.">            if (t == 'R')</span>
            {
<span class="fc" id="L613">                c_BKRemove rem = (c_BKRemove) c;</span>
                
<span class="fc" id="L615">                List&lt;Integer&gt; set2 = new ArrayList&lt;&gt;(rem.pkPrimeMap.keySet());</span>
<span class="fc" id="L616">                int leafNodeIndex = Tree.findLeafIndexFromSet(set2, tree);</span>
<span class="fc" id="L617">                path_Pk = tree.T_path(leafNodeIndex);</span>
<span class="fc" id="L618">                position = path_Pk.indexOf(lStar);</span>

<span class="fc" id="L620">                List&lt;Integer&gt; set3 = new ArrayList&lt;&gt;(skMap.keySet());</span>
<span class="fc" id="L621">                int leafNodeIndex_sk = Tree.findLeafIndexFromSet(set3, tree);</span>

                // Case when the removed leaf
<span class="fc bfc" id="L624" title="All 2 branches covered.">                if(leafNodeIndex_sk == -1)</span>
                {
<span class="fc" id="L626">                    return new BKProcResult(null, null);</span>
                }

<span class="fc" id="L629">                path_Sk = tree.T_path(leafNodeIndex_sk);</span>
<span class="fc" id="L630">                co_path_Sk = tree.T_co_path(leafNodeIndex_sk);</span>

<span class="fc bfc" id="L632" title="All 2 branches covered.">                if (leafNodeIndex ==leafNodeIndex_sk)</span>
                {
<span class="fc" id="L634">                    lStar = path_Sk.get(0);</span>
                }
<span class="fc" id="L636">                position_InSk = path_Sk.indexOf(lStar);</span>


                // if ((lStar == path_Sk.get(0)) || (leafNodeIndex ==leafNodeIndex_sk))
<span class="fc bfc" id="L640" title="All 2 branches covered.">                if ((lStar == path_Sk.get(0)) )</span>
                {
<span class="fc" id="L642">                    pkR = rem.pkCircle;</span>
<span class="fc" id="L643">                    skL = skMap.get(path_Sk.get(0));</span>
                }
                else
                {
<span class="fc" id="L647">                    pkR = rem.pkPrimeMap.get(path_Pk.get(position - 1));</span>
<span class="fc" id="L648">                    skL = skMap.get(path_Sk.get(position_InSk - 1));</span>
                    // pkR = rem.pkPrimeMap.get(path_Pk.get(position + 1));
                    // skL = skMap.get(path_Sk.get(position_InSk + 1));
                }
<span class="fc" id="L652">            }</span>
            else
            {

<span class="fc" id="L656">                c_BKAdd add = (c_BKAdd) c;</span>
<span class="fc" id="L657">                List&lt;Integer&gt; set2 = new ArrayList&lt;&gt;(add.pk_lMap.keySet());</span>
<span class="fc" id="L658">                int leafNodeIndex = Tree.findLeafIndexFromSet(set2, tree);</span>
<span class="fc" id="L659">                path_Pk = tree.T_path(leafNodeIndex);</span>
<span class="fc" id="L660">                position = path_Pk.indexOf(lStar);</span>

<span class="fc" id="L662">                List&lt;Integer&gt; set3 = new ArrayList&lt;&gt;(skMap.keySet());</span>
<span class="fc" id="L663">                int leafNodeIndex_sk = Tree.findLeafIndexFromSet(set3, tree);</span>
<span class="fc" id="L664">                path_Sk = tree.T_path(leafNodeIndex_sk);</span>
<span class="fc" id="L665">                co_path_Sk = tree.T_co_path(leafNodeIndex_sk);</span>
<span class="fc" id="L666">                position_InSk = path_Sk.indexOf(lStar);</span>

<span class="fc" id="L668">                pkR = add.pk_lMap.get(path_Pk.get(position - 1));</span>
<span class="fc" id="L669">                skL = skMap.get(path_Sk.get(position_InSk - 1));</span>
                // pkR = add.pk_lMap.get(path_Pk.get(position + 1));
                // skL = skMap.get(path_Sk.get(position_InSk + 1));
            }

<span class="fc" id="L674">            byte[] k = Nike.key(skL, pkR);</span>
<span class="fc" id="L675">            RandomOracle.RandomOracleResult ro = RandomOracle.H(k, pkR);</span>
<span class="fc" id="L676">            byte[] s = ro.getS();</span>
<span class="fc" id="L677">            byte[] sPrime = ro.getK();</span>

<span class="fc" id="L679">            skMap.put(path_Sk.get(position_InSk), Nike.gen(s).getDk());</span>


<span class="fc bfc" id="L682" title="All 2 branches covered.">            for (int jj = position_InSk; jj &lt; ((path_Sk.size())-1) ; jj++)</span>
            {
<span class="fc" id="L684">                Nike.KeyPair kp = Nike.gen(sPrime);</span>
<span class="fc" id="L685">                byte[] sk_l = kp.getDk();</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">                pkR = (t == 'R') ? ((c_BKRemove) c).pkStarMap.get(co_path_Sk.get(jj)) : ((c_BKAdd) c).pkstarMap.get(co_path_Sk.get(jj));</span>
<span class="fc" id="L687">                k = Nike.key(sk_l, pkR);</span>
<span class="fc" id="L688">                ro = RandomOracle.H(k, kp.getEk());</span>
<span class="fc" id="L689">                s = ro.getS();</span>
<span class="fc" id="L690">                sPrime = ro.getK();</span>

                // skMap.put(path_Sk.get(jj - 1), Nike.gen(s).getDk());
<span class="fc" id="L693">                skMap.put(path_Sk.get(jj + 1), Nike.gen(s).getDk());</span>
            }

<span class="fc" id="L696">            newDk = tree.setPath(i, skMap);</span>
<span class="fc" id="L697">            return new BKProcResult(newDk, null);</span>
        }

<span class="nc" id="L700">        throw new IllegalArgumentException(&quot;Unsupported ciphertext type&quot;);</span>
    }


    // public static void printTreeDiagram(Tree tree) {
    //     Map&lt;Integer, Tree.Node&gt; nodeMap = new HashMap&lt;&gt;();
    //     for (Tree.Node node : tree.getNodesInternal()) {
    //         nodeMap.put(node.getNodeIndex(), node);
    //     }

    //     Tree.Node root = null;
    //     for (Tree.Node node : tree.getNodesInternal()) {
    //         if (node.getRootnode() == -1) { // rootNode == -1 or similar logic
    //             root = node;
    //             break;
    //         }
    //     }

    //     if (root == null) {
    //         System.out.println(&quot;No root node found.&quot;);
    //         return;
    //     }

    //     printTreeRecursive(root, nodeMap, &quot;&quot;, true);
    // }

    // public static void printTreeRecursive(Tree.Node node, Map&lt;Integer, Tree.Node&gt; nodeMap, String prefix, boolean isTail) {
    //     System.out.println(prefix + (isTail ? &quot;└── &quot; : &quot;├── &quot;) + &quot;[&quot; + node.getNodeIndex() + &quot;]&quot;);

    //     Integer left = node.getChildLeftnode();
    //     Integer right = node.getChildRightnode();

    //     List&lt;Tree.Node&gt; children = new ArrayList&lt;&gt;();
    //     if (left != null &amp;&amp; left != -1) children.add(nodeMap.get(left));
    //     if (right != null &amp;&amp; right != -1) children.add(nodeMap.get(right));

    //     for (int i = 0; i &lt; children.size(); i++) {
    //         printTreeRecursive(children.get(i), nodeMap, prefix + (isTail ? &quot;    &quot; : &quot;│   &quot;), i == children.size() - 1);
    //     }
    // }

    // Utility to print byte arrays
    private static void printByteArray(byte[] bytes) {
<span class="nc" id="L743">        StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">        for (byte b : bytes) {</span>
<span class="nc" id="L745">            sb.append(String.format(&quot;%02X&quot;, b));</span>
        }
<span class="nc" id="L747">        System.out.println(sb.toString());</span>
<span class="nc" id="L748">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>