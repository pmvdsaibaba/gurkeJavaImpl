<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>d_MSMR.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">gurkeImp</a> &gt; <a href="index.source.html" class="el_package">com.myproject.d_MSMR</a> &gt; <span class="el_source">d_MSMR.java</span></div><h1>d_MSMR.java</h1><pre class="source lang-java linenums">package com.myproject.d_MSMR;

import com.myproject.dynamicUBKem.UB_KEM;
import com.myproject.dynamicUBKem.UB_KEM.BKGenResult;
import com.myproject.dynamicUBKem.UB_KEM.c_BKAdd;
import com.myproject.dynamicUBKem.UB_KEM.c_BKRemove;
import com.myproject.dynamicUBKem.UB_KEM.c_BKFork;

import com.myproject.dynamicUBKem.UB_KEM.BKEncResult;
import com.myproject.dynamicUBKem.UB_KEM.EncOutput;
import com.myproject.dynamicUBKem.UB_KEM.FinResult;

import com.myproject.standardKEM.KEM.*;
import com.myproject.standardKEM.KEM;

import com.myproject.RandomOracle.RandomOracle;

import com.myproject.Tree.TreeEK;
import com.myproject.Tree.TreeDk;
import com.myproject.Tree.Tree;
import com.myproject.signatureScheme.SignatureScheme;

import java.util.Set;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;
import java.util.*;

import java.util.Map;
import java.util.HashMap;

import java.util.Queue;
import java.util.LinkedList;
import java.util.Arrays;

import java.io.ByteArrayOutputStream;
import java.io.IOException;


import org.bouncycastle.crypto.generators.HKDFBytesGenerator;
import org.bouncycastle.crypto.params.HKDFParameters;
import org.bouncycastle.crypto.digests.SHA512Digest;

<span class="nc" id="L44">public class d_MSMR {</span>

    // Operation types
<span class="fc" id="L47">    public enum OpType {</span>
<span class="fc" id="L48">        ADD, REMOVE</span>
    }

    // Target types
<span class="fc" id="L52">    public enum TargetType {</span>
<span class="fc" id="L53">        SENDER, RECEIVER</span>
    }

    public static class QueuedOperation {
        public OpType op;
        public TargetType t;
        public int uid;
        public Object diff;
        // public TreeEK ekuidR;
        public byte[] ekuidR;

<span class="fc" id="L64">        public QueuedOperation(OpType op, TargetType t, int uid, Object diff, byte[] ekuidR) {</span>
<span class="fc" id="L65">            this.op = op;</span>
<span class="fc" id="L66">            this.t = t;</span>
<span class="fc" id="L67">            this.uid = uid;</span>
<span class="fc" id="L68">            this.diff = diff;</span>
<span class="fc" id="L69">            this.ekuidR = ekuidR;</span>
<span class="fc" id="L70">        }</span>
    }


    public static class SenderState {
        public int i;
        public Set&lt;Integer&gt; memS;
        public Set&lt;Integer&gt; memR;
        public TreeEK ek;
        public byte[] ssk;
        public byte[] svk;
        public byte[] tr;
        public Queue&lt;QueuedOperation&gt; ops;

        public SenderState(int i, Set&lt;Integer&gt; memS, Set&lt;Integer&gt; memR, TreeEK ek, 
<span class="fc" id="L85">                          byte[] ssk, byte[] svk, byte[] tr, Queue&lt;QueuedOperation&gt; ops) {</span>
<span class="fc" id="L86">            this.i = i;</span>
<span class="fc" id="L87">            this.memS = new HashSet&lt;&gt;(memS);</span>
<span class="fc" id="L88">            this.memR = new HashSet&lt;&gt;(memR);</span>
<span class="fc" id="L89">            this.ek = ek;</span>
<span class="fc" id="L90">            this.ssk = ssk;</span>
<span class="fc" id="L91">            this.svk = svk;</span>
<span class="fc" id="L92">            this.tr = tr;</span>
<span class="fc" id="L93">            this.ops = new LinkedList&lt;&gt;(ops);</span>
<span class="fc" id="L94">        }</span>
    }

    public static class SenderStateInReceiver {
        public Set&lt;Integer&gt; memS;
        public Set&lt;Integer&gt; memR;
        public Map&lt;Integer, TreeDk&gt; dkMap; // St[i] for each sender i
        public Map&lt;Integer, byte[]&gt; kemDkMap; // KEM decapsulation keys for each sender i (if any)
        public Map&lt;Integer, byte[]&gt; svkMap; // svk for each sender i
        public Map&lt;Integer, byte[]&gt; trMap; // tr for each sender i

        public SenderStateInReceiver(Set&lt;Integer&gt; memS, Set&lt;Integer&gt; memR, Map&lt;Integer, TreeDk&gt; dkMap,
<span class="fc" id="L106">                           Map&lt;Integer, byte[]&gt; kemDkMap, Map&lt;Integer, byte[]&gt; svkMap, Map&lt;Integer, byte[]&gt; trMap) {</span>
<span class="fc" id="L107">            this.memS = new HashSet&lt;&gt;(memS);</span>
<span class="fc" id="L108">            this.memR = new HashSet&lt;&gt;(memR);</span>
<span class="fc" id="L109">            this.dkMap = new HashMap&lt;&gt;(dkMap);</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">            this.kemDkMap = kemDkMap != null ? new HashMap&lt;&gt;(kemDkMap) : null;</span>
<span class="fc" id="L111">            this.svkMap = new HashMap&lt;&gt;(svkMap);</span>
<span class="fc" id="L112">            this.trMap = new HashMap&lt;&gt;(trMap);</span>
<span class="fc" id="L113">        }</span>
    }


    // New type to hold isNewAddRcvr and receiver state map
    public static class ReceiverEntry {
        public boolean isNewAddRcvr;
        public Map&lt;Integer, SenderStateInReceiver&gt; stateMap;

<span class="fc" id="L122">        public ReceiverEntry(boolean isNewAddRcvr, Map&lt;Integer, SenderStateInReceiver&gt; stateMap) {</span>
<span class="fc" id="L123">            this.isNewAddRcvr = isNewAddRcvr;</span>
<span class="fc" id="L124">            this.stateMap = stateMap;</span>
<span class="fc" id="L125">        }</span>
    }

    public static class InitResult {
        public Map&lt;Integer, SenderState&gt; senderStates;
        public Map&lt;Integer, ReceiverEntry&gt; receiverStatesMap;

<span class="fc" id="L132">        public InitResult(Map&lt;Integer, SenderState&gt; senderStates, Map&lt;Integer, ReceiverEntry&gt; receiverStatesMap) {</span>
<span class="fc" id="L133">            this.senderStates = senderStates;</span>
<span class="fc" id="L134">            this.receiverStatesMap = receiverStatesMap;</span>
<span class="fc" id="L135">        }</span>
    }



////////////////////////////////////////////////////
    // Proc init(nS, nR)
////////////////////////////////////////////////////
    public static InitResult procInit(int nS, int nR) throws Exception
    {
<span class="fc" id="L145">        Map&lt;Integer, SenderState&gt; senderStates = new HashMap&lt;&gt;();</span>

<span class="fc" id="L147">        Map&lt;Integer, ReceiverEntry&gt; receiverStateMap = new HashMap&lt;&gt;();</span>

        // For each receiver, create ReceiverEntry with isNewAddRcvr=false and empty stateMap
<span class="fc bfc" id="L150" title="All 2 branches covered.">        for (int j = 1; j &lt;= nR; j++) {</span>
<span class="fc" id="L151">            receiverStateMap.put(j, new ReceiverEntry(false, new HashMap&lt;&gt;()));</span>
        }
        // For each sender
<span class="fc bfc" id="L154" title="All 2 branches covered.">        for (int i = 1; i &lt;= nS; i++) {</span>
            // Generate BK keys
<span class="fc" id="L156">            BKGenResult bkGenResult = UB_KEM.gen(nR);</span>
<span class="fc" id="L157">            TreeEK ek = bkGenResult.ek;</span>
<span class="fc" id="L158">            List&lt;TreeDk&gt; dkList = bkGenResult.dkList;</span>

            // Generate signature keys
<span class="fc" id="L161">            SignatureScheme.KeyPair sigKeyPair = SignatureScheme.gen();</span>
<span class="fc" id="L162">            byte[] svk = sigKeyPair.getVk();</span>
<span class="fc" id="L163">            byte[] ssk = sigKeyPair.getSk();</span>

<span class="fc" id="L165">            byte[] tr = new byte[0]; // ε</span>
<span class="fc" id="L166">            Queue&lt;QueuedOperation&gt; ops = new LinkedList&lt;&gt;();</span>

<span class="fc" id="L168">            Set&lt;Integer&gt; memS = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">            for (int s = 1; s &lt;= nS; s++)</span>
            {
<span class="fc" id="L171">                memS.add(s);</span>
            }

<span class="fc" id="L174">            Set&lt;Integer&gt; memR = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">            for (int r = 1; r &lt;= nR; r++) {</span>
<span class="fc" id="L176">                memR.add(r);</span>
            }

<span class="fc" id="L179">            SenderState senderState = new SenderState(i, memS, memR, ek, ssk, svk, tr, ops);</span>
<span class="fc" id="L180">            senderStates.put(i, senderState);</span>

            // Create receiver states for this sender
<span class="fc bfc" id="L183" title="All 2 branches covered.">            for (int j = 1; j &lt;= nR; j++) {</span>
<span class="fc" id="L184">                Map&lt;Integer, TreeDk&gt; dkMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L185">                Map&lt;Integer, byte[]&gt; svkMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L186">                Map&lt;Integer, byte[]&gt; trMap = new HashMap&lt;&gt;();</span>

<span class="fc" id="L188">                dkMap.put(i, dkList.get(j - 1));</span>
<span class="fc" id="L189">                svkMap.put(i, svk);</span>
<span class="fc" id="L190">                trMap.put(i, tr);</span>

<span class="fc" id="L192">                SenderStateInReceiver senderStateInReceiver = new SenderStateInReceiver(memS, memR, dkMap, new HashMap&lt;&gt;(), svkMap, trMap);</span>
<span class="fc" id="L193">                receiverStateMap.get(j).stateMap.put(i, senderStateInReceiver);</span>
            }
        }

<span class="fc" id="L197">        return new InitResult(senderStates, receiverStateMap);</span>
    }

    public static class ToOperation {
        public OpType op;
        public TargetType target;
        public int uid;

<span class="fc" id="L205">        public ToOperation(OpType op, TargetType target, int uid) {</span>
<span class="fc" id="L206">            this.op = op;</span>
<span class="fc" id="L207">            this.target = target;</span>
<span class="fc" id="L208">            this.uid = uid;</span>
<span class="fc" id="L209">        }</span>

        public static ToOperation empty() {
<span class="fc" id="L212">            return new ToOperation(null, null, -1);</span>
        }

        public boolean isEmpty() {
<span class="pc bpc" id="L216" title="2 of 6 branches missed.">            return op == null &amp;&amp; target == null &amp;&amp; uid == -1;</span>
        }
    }

    public static class Kid {
        public byte[] id;
        public int i;
        public Set&lt;Integer&gt; memS;
        public Set&lt;Integer&gt; memR;

<span class="fc" id="L226">        public Kid(byte[] id, int i, Set&lt;Integer&gt; memS, Set&lt;Integer&gt; memR) {</span>
<span class="fc" id="L227">            this.id = id;</span>
<span class="fc" id="L228">            this.i = i;</span>
<span class="fc" id="L229">            this.memS = new HashSet&lt;&gt;(memS);</span>
<span class="fc" id="L230">            this.memR = new HashSet&lt;&gt;(memR);</span>
<span class="fc" id="L231">        }</span>
    }

    public static class EncapsResult {
        public SenderState updatedState;
        public Ciphertext ciphertext;
        public byte[] key;
        public Kid kid;

<span class="fc" id="L240">        public EncapsResult(SenderState updatedState, Ciphertext ciphertext, byte[] key, Kid kid) {</span>
<span class="fc" id="L241">            this.updatedState = updatedState;</span>
<span class="fc" id="L242">            this.ciphertext = ciphertext;</span>
<span class="fc" id="L243">            this.key = key;</span>
<span class="fc" id="L244">            this.kid = kid;</span>
<span class="fc" id="L245">        }</span>
    }

    public static class Ciphertext {
        public int i;
        public byte[] cPrime;
        public Object cM;
        public Queue&lt;QueuedCiphertext&gt; cq;
        public byte[] svkStar;
        public byte[] svkPrime;
        public ToOperation to;
        public byte[] signature;
        public Map&lt;Integer, byte[]&gt; dkjRMap; 

        public Ciphertext(int i, byte[] cPrime, Object cM, Queue&lt;QueuedCiphertext&gt; cq,
                         byte[] svkStar, byte[] svkPrime, ToOperation to, byte[] signature,
<span class="fc" id="L261">                         Map&lt;Integer, byte[]&gt; dkjRMap) { </span>
<span class="fc" id="L262">            this.i = i;</span>
<span class="fc" id="L263">            this.cPrime = cPrime;</span>
<span class="fc" id="L264">            this.cM = cM;</span>
<span class="fc" id="L265">            this.cq = new LinkedList&lt;&gt;(cq);</span>
<span class="fc" id="L266">            this.svkStar = svkStar;</span>
<span class="fc" id="L267">            this.svkPrime = svkPrime;</span>
<span class="fc" id="L268">            this.to = to;</span>
<span class="fc" id="L269">            this.signature = signature;</span>
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">            this.dkjRMap = dkjRMap != null ? new HashMap&lt;&gt;(dkjRMap) : null;</span>
<span class="fc" id="L271">        }</span>
    }

    public static class QueuedCiphertext {
        public OpType op;
        public TargetType t;
        public int uid;
        public Object cM;
        public Object cP;

<span class="fc" id="L281">        public QueuedCiphertext(OpType op, TargetType t, int uid, Object cM, Object cP) {</span>
<span class="fc" id="L282">            this.op = op;</span>
<span class="fc" id="L283">            this.t = t;</span>
<span class="fc" id="L284">            this.uid = uid;</span>
<span class="fc" id="L285">            this.cM = cM;</span>
<span class="fc" id="L286">            this.cP = cP;</span>
<span class="fc" id="L287">        }</span>
    }
//////////////////////////////////////////////////////////
    // Helper Proc encaps(st, ek, ad, cM, cq, svk*, to)
//////////////////////////////////////////////////////////
    private static EncapsResult encaps(SenderState st, TreeEK ek, byte[] ad, Object cM, 
                                      Queue&lt;QueuedCiphertext&gt; cq, byte[] svkStar, ToOperation to, Map&lt;Integer, byte[]&gt; dkjRMap) throws Exception
    {
<span class="fc" id="L295">        BKEncResult encResult = UB_KEM.enc(ek);</span>
<span class="fc" id="L296">        EncOutput u = encResult.u;</span>
<span class="fc" id="L297">        byte[] cPrime = encResult.c;</span>

<span class="fc" id="L299">        SignatureScheme.KeyPair newSigKeys = SignatureScheme.gen();</span>
<span class="fc" id="L300">        byte[] svkPrime = newSigKeys.getVk();</span>
<span class="fc" id="L301">        byte[] sskPrime = newSigKeys.getSk();</span>

        // Create message to sign
<span class="fc" id="L304">        byte[] messageToSign = concatAll(st.tr, ad, intToByteArray(st.i), cPrime, </span>
<span class="fc" id="L305">                                        serializeObject(cM), serializeQueue(cq), </span>
<span class="fc" id="L306">                                        svkStar, svkPrime, serializeToOperation(to));</span>
        
<span class="fc" id="L308">        byte[] sigma = SignatureScheme.sgn(st.ssk, messageToSign);</span>

<span class="fc" id="L310">        Ciphertext cR = new Ciphertext(st.i, cPrime, cM, cq, svkStar, svkPrime, to, sigma, dkjRMap);</span>

<span class="fc" id="L312">        byte[] finInput = concatAll(st.tr, ad, serializeCiphertext(cR));</span>
<span class="fc" id="L313">        FinResult finResult = UB_KEM.fin(u, finInput);</span>
<span class="fc" id="L314">        TreeEK newEk = finResult.ek;</span>

        // Derive keys
<span class="fc" id="L317">        byte[] kdf_k = &quot;kdf_k&quot;.getBytes();</span>
<span class="fc" id="L318">        byte[] kdf_id = &quot;kdf_id&quot;.getBytes();</span>
<span class="fc" id="L319">        byte[] kdf_tr = &quot;kdf_tr&quot;.getBytes();</span>

<span class="fc" id="L321">        byte[] k = deriveKey(finResult.k, kdf_k);</span>
<span class="fc" id="L322">        byte[] id = deriveKey(finResult.k, kdf_id);</span>
<span class="fc" id="L323">        byte[] tr = deriveKey(finResult.k, kdf_tr);</span>

<span class="fc" id="L325">        Kid kid = new Kid(id, st.i, st.memS, st.memR);</span>

        // sender removal
<span class="fc" id="L328">        Set&lt;Integer&gt; memS = new HashSet&lt;&gt;(st.memS);</span>
<span class="fc bfc" id="L329" title="All 4 branches covered.">        if (to.target == TargetType.SENDER &amp;&amp; to.op == OpType.REMOVE) {</span>
<span class="fc" id="L330">            memS.remove(to.uid);</span>
        }

<span class="fc" id="L333">        SenderState updatedState = new SenderState(st.i, memS, st.memR, newEk, sskPrime, svkPrime, tr, st.ops);</span>
        
<span class="fc" id="L335">        return new EncapsResult(updatedState, cR, k, kid);</span>
    }

    public static class EnqOpsResult {
        public SenderState updatedState;
        public Queue&lt;QueuedCiphertext&gt; cq;

<span class="fc" id="L342">        public EnqOpsResult(SenderState updatedState, Queue&lt;QueuedCiphertext&gt; cq) {</span>
<span class="fc" id="L343">            this.updatedState = updatedState;</span>
<span class="fc" id="L344">            this.cq = cq;</span>
<span class="fc" id="L345">        }</span>
    }

//////////////////////////////////////////////////////////
    // Helper Proc enq-ops(st, mem'S, mem'R)
////////////////////////////////////////////////////////////
    private static EnqOpsResult enqOps(SenderState st, Set&lt;Integer&gt; memSPrime, Set&lt;Integer&gt; memRPrime) throws Exception {
<span class="fc" id="L352">        Queue&lt;QueuedCiphertext&gt; cq = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L353">        TreeEK currentEk = st.ek; // Use a local variable instead of updating st.ek</span>

<span class="fc bfc" id="L355" title="All 2 branches covered.">        while (!st.ops.isEmpty())</span>
        {
            /*  Retrieves the next operation to process from the st.ops queue.
                The poll() method is used to retrieve and remove the head (first element) of the queue. If the queue is empty, it returns null. This is a non-blocking operation. */
<span class="fc" id="L359">            QueuedOperation queuedOp = st.ops.poll();</span>
<span class="fc" id="L360">            Object cM = null;</span>
<span class="fc" id="L361">            Object cP = null;</span>

<span class="pc bpc" id="L363" title="2 of 4 branches missed.">            if (queuedOp.t == TargetType.RECEIVER &amp;&amp; queuedOp.op == OpType.ADD) {</span>
                // Receiver add
                // UB_KEM.BKAddResult addResult = UB_KEM.add(st.ek);
                // // todo: if new state is needed or check if updating old state is ok.
                // st.ek = addResult.ek;
<span class="fc" id="L368">                UB_KEM.BKAddResult addResult = UB_KEM.add(currentEk);</span>
<span class="fc" id="L369">                currentEk = addResult.ek; // Do not update st.ek</span>

<span class="fc" id="L371">                TreeDk dk = addResult.dk;</span>
<span class="fc" id="L372">                cM = addResult.c;</span>

                // Encrypt BK dk to receiver
<span class="fc" id="L375">                EncapsulationResult kemEncResult = KEM.enc(queuedOp.ekuidR);</span>
<span class="fc" id="L376">                byte[] c1 = kemEncResult.c;</span>
<span class="fc" id="L377">                byte[] k = kemEncResult.k;</span>

                // Serialize (dk, tr, diff) with length prefixes
<span class="fc" id="L380">                byte[] dkBytes = serializeTreeDk(dk);</span>

                // Just for test and debug. Test is ok, so commented. 
<span class="fc" id="L383">                TreeDk testDk = deserializeTreeDk(dkBytes);</span>

<span class="fc" id="L385">                byte[] trBytes = st.tr;</span>
<span class="fc" id="L386">                byte[] diffBytes = serializeObject_Diff(queuedOp.diff);</span>
<span class="fc" id="L387">                byte[] dkLenBytes = intToByteArray(dkBytes.length);</span>
<span class="fc" id="L388">                byte[] trLenBytes = intToByteArray(trBytes.length);</span>
<span class="fc" id="L389">                byte[] dkTrDiff = concatAll(dkLenBytes, trLenBytes, dkBytes, trBytes, diffBytes);</span>

<span class="fc" id="L391">                byte[] hash = RandomOracle.Hash2(k, c1);</span>
<span class="fc" id="L392">                byte[] c2 = xor(hash, dkTrDiff);</span>

<span class="fc" id="L394">                cP = new Object[]{c1, c2}; // (c1, c2)</span>
<span class="pc bnc" id="L395" title="All 4 branches missed.">            } else if (queuedOp.t == TargetType.RECEIVER &amp;&amp; queuedOp.op == OpType.REMOVE) {</span>
                // Receiver remove
                // UB_KEM.BKRemoveResult removeResult = UB_KEM.rmv(st.ek, queuedOp.uid);
                // st.ek = removeResult.ek;

<span class="nc" id="L400">                UB_KEM.BKRemoveResult removeResult = UB_KEM.rmv(currentEk, queuedOp.uid);</span>
<span class="nc" id="L401">                currentEk = removeResult.ek; // Do not update st.ek</span>

<span class="nc" id="L403">                cM = removeResult.c;</span>
<span class="nc" id="L404">                cP = null;</span>
            }

<span class="fc" id="L407">            QueuedCiphertext qc = new QueuedCiphertext(queuedOp.op, queuedOp.t, queuedOp.uid, cM, cP);</span>

            /* Adds the queued ciphertext to the queue cq. */
<span class="fc" id="L410">            cq.offer(qc);</span>
<span class="fc" id="L411">        }</span>

<span class="fc" id="L413">        SenderState updatedState = new SenderState(st.i, memSPrime, memRPrime, currentEk, st.ssk, st.svk, st.tr, st.ops);</span>
<span class="fc" id="L414">        return new EnqOpsResult(updatedState, cq);</span>
    }




    public static class DeqOpsResult {
        public Set&lt;Integer&gt; memS;
        public Set&lt;Integer&gt; memR;
        public TreeDk dk;
        public byte[] svk;
        public byte[] tr;

<span class="fc" id="L427">        public DeqOpsResult(Set&lt;Integer&gt; memS, Set&lt;Integer&gt; memR, TreeDk dk, byte[] svk, byte[] tr) {</span>
<span class="fc" id="L428">            this.memS = new HashSet&lt;&gt;(memS);</span>
<span class="fc" id="L429">            this.memR = new HashSet&lt;&gt;(memR);</span>
<span class="fc" id="L430">            this.dk = dk;</span>
<span class="fc" id="L431">            this.svk = svk;</span>
<span class="fc" id="L432">            this.tr = tr;</span>
<span class="fc" id="L433">        }</span>
    }

//////////////////////////////////////////////////////////
    // Helper Proc deq-ops(st, cq, i)
////////////////////////////////////////////////////////////


    // Updated deqOps: now takes kemDkMap as an argument for KEM decapsulation
    private static DeqOpsResult deqOps(Set&lt;Integer&gt; memS, Set&lt;Integer&gt; memR, TreeDk dk,
                                       byte[] svk, byte[] tr, Queue&lt;QueuedCiphertext&gt; cq, int i,
                                       Map&lt;Integer, byte[]&gt; kemDkMap, Map&lt;Integer, byte[]&gt; dkjRMap) throws Exception {
        // 62. (memS,memR, dk, svk, tr) ← st
<span class="fc" id="L446">        Set&lt;Integer&gt; currentMemS = new HashSet&lt;&gt;(memS);</span>
<span class="fc" id="L447">        Set&lt;Integer&gt; currentMemR = new HashSet&lt;&gt;(memR);</span>
<span class="fc" id="L448">        TreeDk currentDk = dk;</span>
<span class="fc" id="L449">        byte[] currentSvk = svk;</span>
<span class="fc" id="L450">        byte[] currentTr = tr;</span>

        // 63. While cq.first() ̸= ⊥:
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">        while (!cq.isEmpty()) {</span>
            // 64. (op, t, uid, cM, cP ) ← cq.dequeue()
<span class="nc" id="L455">            QueuedCiphertext qc = cq.poll();</span>
<span class="nc" id="L456">            OpType op = qc.op;</span>
<span class="nc" id="L457">            TargetType t = qc.t;</span>
<span class="nc" id="L458">            int uid = qc.uid;</span>
<span class="nc" id="L459">            Object cM = qc.cM;</span>
<span class="nc" id="L460">            Object cP = qc.cP;</span>

            // 65. If tr = ϵ:
<span class="nc bnc" id="L463" title="All 2 branches missed.">            if (currentTr.length == 0) {</span>
                // 66. If t = R ∧ op = A:
<span class="nc bnc" id="L465" title="All 4 branches missed.">                if (t == TargetType.RECEIVER &amp;&amp; op == OpType.ADD) {</span>
                    // 67. // Init msg from sender i
<span class="nc bnc" id="L467" title="All 2 branches missed.">                    if (cP instanceof Object[]) {</span>
<span class="nc" id="L468">                        Object[] cPArray = (Object[]) cP;</span>
<span class="nc" id="L469">                        byte[] c1 = (byte[]) cPArray[0];</span>
<span class="nc" id="L470">                        byte[] c2 = (byte[]) cPArray[1];</span>

                        // Use kemDkMap for KEM decapsulation key (must be present for KEM decapsulation)
                        // if (kemDkMap == null || !kemDkMap.containsKey(i)) {
                        //     throw new IllegalStateException(&quot;KEM decapsulation key missing for i=&quot; + i + &quot;. This is a protocol error.&quot;);
                        // }

<span class="nc bnc" id="L477" title="All 4 branches missed.">                        if (dkjRMap == null || !dkjRMap.containsKey(i)) {</span>
<span class="nc" id="L478">                            throw new IllegalStateException(&quot;KEM decapsulation key missing for i=&quot; + i + &quot;. This is a protocol error.&quot;);</span>
                        }

<span class="nc" id="L481">                        byte[] kemDk = dkjRMap.get(i);</span>
<span class="nc" id="L482">                        KEM.DecapsulationResult kemDecResult = KEM.dec(kemDk, c1);</span>
<span class="nc" id="L483">                        byte[] k = kemDecResult.getK();</span>

<span class="nc" id="L485">                        byte[] hash = RandomOracle.Hash2(k, c1);</span>
<span class="nc" id="L486">                        byte[] plaintext = xor(c2, hash);</span>

<span class="nc" id="L488">                        int dkLen = byteArrayToInt(Arrays.copyOfRange(plaintext, 0, 4));</span>
<span class="nc" id="L489">                        int trLen = byteArrayToInt(Arrays.copyOfRange(plaintext, 4, 8));</span>
<span class="nc" id="L490">                        byte[] dkBytes = Arrays.copyOfRange(plaintext, 8, 8 + dkLen);</span>
<span class="nc" id="L491">                        byte[] trBytes = Arrays.copyOfRange(plaintext, 8 + dkLen, 8 + dkLen + trLen);</span>
<span class="nc" id="L492">                        byte[] diffBytes = Arrays.copyOfRange(plaintext, 8 + dkLen + trLen, plaintext.length);</span>

<span class="nc" id="L494">                        TreeDk newDk = deserializeTreeDk(dkBytes);</span>
<span class="nc" id="L495">                        byte[] newTr = trBytes;</span>
<span class="nc" id="L496">                        Diff diffResult = deserializeDiff(diffBytes);</span>

<span class="nc" id="L498">                        currentDk = newDk;</span>
<span class="nc" id="L499">                        currentTr = newTr;</span>

<span class="nc" id="L501">                        MergeDiffResult mergeResult = mergeDiff(currentMemS, currentMemR,</span>
                                diffResult.senderAdd, diffResult.senderRemove,
                                diffResult.receiverAdd, diffResult.receiverRemove);
<span class="nc" id="L504">                        currentMemS = mergeResult.newMemS;</span>
<span class="nc" id="L505">                        currentMemR = mergeResult.newMemR;</span>
<span class="nc" id="L506">                    }</span>
                } else {
                    // 75. Continue // Ignore until init from i
                    continue;
                }
            } else {
                // 76. If op = A: memt∪←{uid}
                // 77. Else: memt ← memt \ {uid}
<span class="nc bnc" id="L514" title="All 2 branches missed.">                if (op == OpType.ADD) {</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">                    if (t == TargetType.SENDER) {</span>
<span class="nc" id="L516">                        currentMemS.add(uid);</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">                    } else if (t == TargetType.RECEIVER) {</span>
<span class="nc" id="L518">                        currentMemR.add(uid);</span>
                    }
<span class="nc bnc" id="L520" title="All 2 branches missed.">                } else if (op == OpType.REMOVE) {</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">                    if (t == TargetType.SENDER) {</span>
<span class="nc" id="L522">                        currentMemS.remove(uid);</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">                    } else if (t == TargetType.RECEIVER) {</span>
<span class="nc" id="L524">                        currentMemR.remove(uid);</span>
                    }
                }

                // 78. If t = R:
<span class="nc bnc" id="L529" title="All 4 branches missed.">                if (t == TargetType.RECEIVER &amp;&amp; cM != null) {</span>
                    // 79. (uid, dk, dk∗) ← BK.proc(dk, cM)
<span class="nc" id="L531">                    UB_KEM.BKProcResult procResult = UB_KEM.proc(currentDk, cM);</span>
<span class="nc" id="L532">                    currentDk = procResult.dk1;</span>
                    // Handle forked keys if needed
                }
                // 80. st ← (memS,memR, dk, svk, tr)
            }
<span class="nc" id="L537">        }</span>
        // 81. Return st
<span class="fc" id="L539">        return new DeqOpsResult(currentMemS, currentMemR, currentDk, currentSvk, currentTr);</span>
    }

//     private static DeqOpsResult deqOps(Set&lt;Integer&gt; memS, Set&lt;Integer&gt; memR, TreeDk dk, 
//                                     byte[] svk, byte[] tr, Queue&lt;QueuedCiphertext&gt; cq, int i) throws Exception
//     {
//         Set&lt;Integer&gt; currentMemS = new HashSet&lt;&gt;(memS);
//         Set&lt;Integer&gt; currentMemR = new HashSet&lt;&gt;(memR);
//         // Dk could be of type bytes or MapTreeDk
//         TreeDk currentDk = dk;
//         byte[] currentSvk = svk;
//         byte[] currentTr = tr;

//         while (!cq.isEmpty())
//         {
//             QueuedCiphertext qc = cq.poll();
//             OpType op = qc.op;
//             TargetType t = qc.t;
//             int uid = qc.uid;
//             Object cM = qc.cM;
//             Object cP = qc.cP;

//             // If tr is empty (uninitialized)
//             if (currentTr.length == 0)
//             {
//                 if (t == TargetType.RECEIVER &amp;&amp; op == OpType.ADD)
//                 {
// /////////////////////////////////////////////////////////////
// // This code need to be fixed.
// // there should be a new parameter dk different from TreeDk
// /////////////////////////////////////////////////////////////
//                     // // Init message from sender i
//                     // if (cP instanceof Object[])
//                     // {
//                     //     Object[] cPArray = (Object[]) cP;
//                     //     byte[] c1 = (byte[]) cPArray[0];
//                     //     byte[] c2 = (byte[]) cPArray[1];

//                     //     // Decrypt
//                     //     // Todo: Verify for the case when Receiver is added Dk is of type, Bytes
//                     //     DecapsulationResult kemDecResult = KEM.dec(currentDk, c1);
//                     //     byte[] k = kemDecResult.k;

//                     //     // Derive plaintext
//                     //     byte[] hashInput = concatAll(k, c1);
//                     //     byte[] hash = computeHash(hashInput);
//                     //     byte[] plaintext = xor(c2, hash);

//                     //     // Parse plaintext (dk, tr, diff)
//                     //     // This is a simplified parsing - in practice you'd need proper deserialization
//                     //     currentDk = deserializeTreeDk(plaintext); // Extract dk
//                     //     currentTr = extractTr(plaintext); // Extract tr
//                     //     Diff diffResult = extractDiff(plaintext); // Extract diff

//                     //     // Merge diff into membership sets
//                     //     MergeDiffResult mergeResult = mergeDiff(currentMemS, currentMemR, 
//                     //                                         diffResult.senderAdd, diffResult.senderRemove,
//                     //                                         diffResult.receiverAdd, diffResult.receiverRemove);
//                     //     currentMemS = mergeResult.newMemS;
//                     //     currentMemR = mergeResult.newMemR;
//                     // }
//                 } else {
//                     // Ignore until init from sender i
//                     continue;
//                 }
//             }

//             // Update membership based on operation
//             if (op == OpType.ADD) {
//                 if (t == TargetType.SENDER) {
//                     currentMemS.add(uid);
//                 } else if (t == TargetType.RECEIVER) {
//                     currentMemR.add(uid);
//                 }
//             } else if (op == OpType.REMOVE) {
//                 if (t == TargetType.SENDER) {
//                     currentMemS.remove(uid);
//                 } else if (t == TargetType.RECEIVER) {
//                     currentMemR.remove(uid);
//                 }
//             }

//             // Process BK operations for receivers
//             if (t == TargetType.RECEIVER &amp;&amp; cM != null)
//             {
//                 UB_KEM.BKProcResult procResult = UB_KEM.proc(currentDk, cM);
//                 // BKRemoveResult procResult = UB_KEM.proc(currentDk, cM);
//                 // UB_KEM.proc retrun type is different from what is expected here
//                 currentDk = procResult.dk1;
//                 // Handle forked keys if needed
//             }
//         }

//         return new DeqOpsResult(currentMemS, currentMemR, currentDk, currentSvk, currentTr);
//     }


////////////////////////////////////////////////////
// Proc rcv(st, ad, c)
////////////////////////////////////////////////////
    public static ReceiveResult procRcv(ReceiverEntry st, byte[] ad, Ciphertext c) throws Exception
    {
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L642">            return new ReceiveResult(st, null, null, false);</span>
        }

        // Parse ciphertext
<span class="fc" id="L646">        int i = c.i;</span>
<span class="fc" id="L647">        byte[] cPrime = c.cPrime;</span>
<span class="fc" id="L648">        Object cM = c.cM;</span>
<span class="fc" id="L649">        Queue&lt;QueuedCiphertext&gt; cq = c.cq;</span>
<span class="fc" id="L650">        byte[] svkStar = c.svkStar;</span>
<span class="fc" id="L651">        byte[] svkPrime = c.svkPrime;</span>
<span class="fc" id="L652">        ToOperation to = c.to;</span>
<span class="fc" id="L653">        byte[] sigma = c.signature;</span>
<span class="fc" id="L654">        Map&lt;Integer, byte[]&gt; dkjRMap = c.dkjRMap;</span>

<span class="fc" id="L656">        SenderStateInReceiver ST = st.stateMap.get(i);</span>
<span class="pc bpc" id="L657" title="4 of 8 branches missed.">        if (ST == null || !ST.dkMap.containsKey(i) || !ST.svkMap.containsKey(i) || !ST.trMap.containsKey(i)) {</span>
<span class="nc" id="L658">            return new ReceiveResult(st, null, null, false);</span>
        }

<span class="fc" id="L661">        OpType op = to.op;</span>
<span class="fc" id="L662">        TargetType t = to.target;</span>
<span class="fc" id="L663">        int uid = to.uid;</span>

<span class="fc" id="L665">        TreeDk dk = ST.dkMap.get(i);</span>
<span class="fc" id="L666">        byte[] svk = ST.svkMap.get(i);</span>
<span class="fc" id="L667">        byte[] tr = ST.trMap.get(i);</span>
<span class="fc" id="L668">        Set&lt;Integer&gt; memS = new HashSet&lt;&gt;(ST.memS);</span>
<span class="fc" id="L669">        Set&lt;Integer&gt; memR = new HashSet&lt;&gt;(ST.memR);</span>

        // Dequeue operations (pass kemDkMap for KEM decapsulation)
<span class="fc" id="L672">        DeqOpsResult deqResult = deqOps(memS, memR, dk, svk, tr, cq, i, ST.kemDkMap, dkjRMap);</span>
<span class="fc" id="L673">        memS = deqResult.memS;</span>
<span class="fc" id="L674">        memR = deqResult.memR;</span>
<span class="fc" id="L675">        dk = deqResult.dk;</span>
<span class="fc" id="L676">        svk = deqResult.svk;</span>
<span class="fc" id="L677">        tr = deqResult.tr;</span>

        // Verify signature
<span class="fc" id="L680">        byte[] messageToVerify = concatAll(tr, ad, intToByteArray(c.i), cPrime, serializeObject(cM), </span>
<span class="fc" id="L681">                                        serializeQueue(cq), svkStar, svkPrime, </span>
<span class="fc" id="L682">                                        serializeToOperation(to));</span>
        
<span class="pc bpc" id="L684" title="1 of 2 branches missed.">        if (!SignatureScheme.vfy(svk, messageToVerify, sigma)) {</span>
<span class="nc" id="L685">            return new ReceiveResult(st, null, null, false);</span>
        }

<span class="fc" id="L688">        boolean isNewAddRcvr = st.isNewAddRcvr;</span>

        // Process cM if not empty
<span class="pc bpc" id="L691" title="1 of 4 branches missed.">       if (cM != null &amp;&amp; !isEmptyObject(cM))</span>
       {
<span class="fc bfc" id="L693" title="All 2 branches covered.">            if (isNewAddRcvr == true)</span>
            {
<span class="fc" id="L695">                isNewAddRcvr = false;</span>
            }
            else
            {
<span class="fc" id="L699">                UB_KEM.BKProcResult procResult = UB_KEM.proc(dk, cM);</span>
<span class="fc" id="L700">                dk = procResult.dk1;</span>
<span class="fc" id="L701">                TreeDk dkStar = procResult.dk2;</span>

<span class="fc bfc" id="L703" title="All 2 branches covered.">                if (dk == null) {</span>
<span class="fc" id="L704">                    return new ReceiveResult(st, null, null, false);</span>
                }
                // int uid = procResult.uid;
                // Todo: There is issue with algorithm.
                // int uid = 10001;

                // If forked
<span class="fc bfc" id="L711" title="All 2 branches covered.">                if (dkStar != null) {</span>
                    // Add new sender state
                    // ST.dkMap.put(uid, dkStar);
                    // ST.svkMap.put(uid, svkStar);
                    // ST.trMap.put(uid, new byte[0]); // ε

<span class="fc" id="L717">                    Map&lt;Integer, TreeDk&gt; dkMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L718">                    Map&lt;Integer, byte[]&gt; svkMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L719">                    Map&lt;Integer, byte[]&gt; trMap = new HashMap&lt;&gt;();</span>

<span class="fc" id="L721">                    dkMap.put(uid, dkStar);</span>
<span class="fc" id="L722">                    svkMap.put(uid, svkStar);</span>
<span class="fc" id="L723">                    trMap.put(uid, new byte[0]); // ε</span>

<span class="fc" id="L725">                    SenderStateInReceiver newSenderState = new SenderStateInReceiver(new HashSet&lt;&gt;(memS), new HashSet&lt;&gt;(memR), dkMap, new HashMap&lt;&gt;(), svkMap, trMap);</span>
<span class="fc" id="L726">                    st.stateMap.put(uid, newSenderState);</span>
                }

                    // Update membership based on operation
<span class="fc bfc" id="L730" title="All 2 branches covered.">                    if (to.op == OpType.ADD) {</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">                        if (to.target == TargetType.SENDER) {</span>
<span class="fc" id="L732">                            memS.add(uid);</span>
<span class="pc bpc" id="L733" title="1 of 2 branches missed.">                        } else if (to.target == TargetType.RECEIVER) {</span>
<span class="fc" id="L734">                            memR.add(uid);</span>
                        }
<span class="pc bpc" id="L736" title="1 of 2 branches missed.">                    } else if (to.op == OpType.REMOVE) {</span>
<span class="pc bpc" id="L737" title="1 of 2 branches missed.">                        if (to.target == TargetType.RECEIVER) {</span>
<span class="fc" id="L738">                            memR.remove(uid);</span>
                        }
                    }
            }
        }

        // Decrypt
<span class="fc" id="L745">        byte[] finInput = concatAll(tr, ad, serializeCiphertext(c));</span>
<span class="fc" id="L746">        UB_KEM.DecResult decResult = UB_KEM.dec(dk, finInput, cPrime);</span>
<span class="fc" id="L747">        dk = decResult.dk;</span>

<span class="fc" id="L749">        byte[] kdf_k = &quot;kdf_k&quot;.getBytes();</span>
<span class="fc" id="L750">        byte[] kdf_id = &quot;kdf_id&quot;.getBytes();</span>
<span class="fc" id="L751">        byte[] kdf_tr = &quot;kdf_tr&quot;.getBytes();</span>

<span class="fc" id="L753">        byte[] k = deriveKey(decResult.k, kdf_k);</span>
<span class="fc" id="L754">        byte[] id = deriveKey(decResult.k, kdf_id);</span>
<span class="fc" id="L755">        byte[] newTr = deriveKey(decResult.k, kdf_tr);</span>

<span class="fc" id="L757">        Kid kid = new Kid(id, i, memS, memR);</span>

        // Handle sender removal
<span class="fc bfc" id="L760" title="All 4 branches covered.">        if (to.op == OpType.REMOVE &amp;&amp; to.target == TargetType.SENDER) {</span>
<span class="fc" id="L761">            memS.remove(to.uid);</span>
<span class="pc bpc" id="L762" title="1 of 2 branches missed.">            if (to.uid == i) {</span>
                // Current sender removed, remove from state
<span class="nc" id="L764">                ST.dkMap.remove(i);</span>
<span class="nc" id="L765">                ST.svkMap.remove(i);</span>
<span class="nc" id="L766">                ST.trMap.remove(i);</span>
            }
        }

        // Update state for sender i
<span class="fc" id="L771">        ST.dkMap.put(i, dk);</span>
<span class="fc" id="L772">        ST.svkMap.put(i, svkPrime);</span>
<span class="fc" id="L773">        ST.trMap.put(i, newTr);</span>

<span class="fc" id="L775">        SenderStateInReceiver updatedState = new SenderStateInReceiver(memS, memR, ST.dkMap, ST.kemDkMap, ST.svkMap, ST.trMap);</span>
<span class="fc" id="L776">        st.isNewAddRcvr = isNewAddRcvr;</span>
<span class="fc" id="L777">        st.stateMap.put(i, updatedState);</span>

<span class="fc" id="L779">        return new ReceiveResult(st, k, kid, true);</span>
    }

    public static class ReceiveResult {
        public ReceiverEntry updatedState;
        public byte[] key;
        public Kid kid;
        public boolean success;

<span class="fc" id="L788">        public ReceiveResult(ReceiverEntry updatedState, byte[] key, Kid kid, boolean success) {</span>
<span class="fc" id="L789">            this.updatedState = updatedState;</span>
<span class="fc" id="L790">            this.key = key;</span>
<span class="fc" id="L791">            this.kid = kid;</span>
<span class="fc" id="L792">            this.success = success;</span>
<span class="fc" id="L793">        }</span>
    }
    private static boolean isEmptyObject(Object obj) {
        // Check if object represents empty/null value
<span class="pc bpc" id="L797" title="4 of 6 branches missed.">        return obj == null || (obj instanceof byte[] &amp;&amp; ((byte[]) obj).length == 0);</span>
    }

    public static class Diff {
        public Set&lt;Integer&gt; senderAdd;
        public Set&lt;Integer&gt; senderRemove;
        public Set&lt;Integer&gt; receiverAdd;
        public Set&lt;Integer&gt; receiverRemove;

        public Diff(Set&lt;Integer&gt; senderAdd, Set&lt;Integer&gt; senderRemove, 
<span class="fc" id="L807">                    Set&lt;Integer&gt; receiverAdd, Set&lt;Integer&gt; receiverRemove) {</span>
<span class="fc" id="L808">            this.senderAdd = new HashSet&lt;&gt;(senderAdd);</span>
<span class="fc" id="L809">            this.senderRemove = new HashSet&lt;&gt;(senderRemove);</span>
<span class="fc" id="L810">            this.receiverAdd = new HashSet&lt;&gt;(receiverAdd);</span>
<span class="fc" id="L811">            this.receiverRemove = new HashSet&lt;&gt;(receiverRemove);</span>
<span class="fc" id="L812">        }</span>
    }

    public static class MergeDiffResult {
        public Set&lt;Integer&gt; newMemS;
        public Set&lt;Integer&gt; newMemR;

<span class="nc" id="L819">        public MergeDiffResult(Set&lt;Integer&gt; newMemS, Set&lt;Integer&gt; newMemR) {</span>
<span class="nc" id="L820">            this.newMemS = new HashSet&lt;&gt;(newMemS);</span>
<span class="nc" id="L821">            this.newMemR = new HashSet&lt;&gt;(newMemR);</span>
<span class="nc" id="L822">        }</span>
    }

    // Helper Proc diff(A, A', B, B')
    private static Diff diff(Set&lt;Integer&gt; A, Set&lt;Integer&gt; APrime, Set&lt;Integer&gt; B, Set&lt;Integer&gt; BPrime) {
<span class="fc" id="L827">        Set&lt;Integer&gt; senderAdd = new HashSet&lt;&gt;(APrime);</span>
<span class="fc" id="L828">        senderAdd.removeAll(A);</span>
        
<span class="fc" id="L830">        Set&lt;Integer&gt; senderRemove = new HashSet&lt;&gt;(A);</span>
<span class="fc" id="L831">        senderRemove.removeAll(APrime);</span>
        
<span class="fc" id="L833">        Set&lt;Integer&gt; receiverAdd = new HashSet&lt;&gt;(BPrime);</span>
<span class="fc" id="L834">        receiverAdd.removeAll(B);</span>
        
<span class="fc" id="L836">        Set&lt;Integer&gt; receiverRemove = new HashSet&lt;&gt;(B);</span>
<span class="fc" id="L837">        receiverRemove.removeAll(BPrime);</span>
        
<span class="fc" id="L839">        return new Diff(senderAdd, senderRemove, receiverAdd, receiverRemove);</span>
    }

    // Helper Proc merge-diff(A, B, A+, A-, B+, B-)
    private static MergeDiffResult mergeDiff(Set&lt;Integer&gt; A, Set&lt;Integer&gt; B, 
                                            Set&lt;Integer&gt; APlus, Set&lt;Integer&gt; AMinus,
                                            Set&lt;Integer&gt; BPlus, Set&lt;Integer&gt; BMinus) {
<span class="nc" id="L846">        Set&lt;Integer&gt; newMemS = new HashSet&lt;&gt;(A);</span>
<span class="nc" id="L847">        newMemS.addAll(APlus);</span>
<span class="nc" id="L848">        newMemS.removeAll(AMinus);</span>
        
<span class="nc" id="L850">        Set&lt;Integer&gt; newMemR = new HashSet&lt;&gt;(B);</span>
<span class="nc" id="L851">        newMemR.addAll(BPlus);</span>
<span class="nc" id="L852">        newMemR.removeAll(BMinus);</span>
        
<span class="nc" id="L854">        return new MergeDiffResult(newMemS, newMemR);</span>
    }

////////////////////////////////////////////////
    // Proc snd(st, ad)
///////////////////////////////////////////////
    public static SendResult procSnd(SenderState st, byte[] ad) throws Exception {
        // Run queued ops first
<span class="fc" id="L862">        EnqOpsResult enqResult = enqOps(st, st.memS, st.memR);</span>
<span class="fc" id="L863">        st = enqResult.updatedState;</span>
<span class="fc" id="L864">        Queue&lt;QueuedCiphertext&gt; cq = enqResult.cq;</span>

<span class="fc" id="L866">        ToOperation to = ToOperation.empty();</span>

        // EncapsResult encapsResult = encaps(st, st.ek, ad, null, cq, new byte[0], to);

<span class="fc" id="L870">        Map&lt;Integer, byte[]&gt; dkjRMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L871">        EncapsResult encapsResult = encaps(st, st.ek, ad, null, cq, new byte[0], to, dkjRMap);</span>
        
<span class="fc" id="L873">        return new SendResult(encapsResult.updatedState, encapsResult.ciphertext, </span>
                             encapsResult.key, encapsResult.kid);
    }

    public static class SendResult {
        public SenderState updatedState;
        public Ciphertext ciphertext;
        public byte[] key;
        public Kid kid;

<span class="fc" id="L883">        public SendResult(SenderState updatedState, Ciphertext ciphertext, byte[] key, Kid kid) {</span>
<span class="fc" id="L884">            this.updatedState = updatedState;</span>
<span class="fc" id="L885">            this.ciphertext = ciphertext;</span>
<span class="fc" id="L886">            this.key = key;</span>
<span class="fc" id="L887">            this.kid = kid;</span>
<span class="fc" id="L888">        }</span>
    }


    // Result class for procAddS
    public static class AddSResult {
        public SenderState updatedSenderState;
        public SenderState newSenderState;
        public CiphertextS cS;
        public Ciphertext cR;
        public byte[] key;
        public Kid kid;

<span class="fc" id="L901">        public AddSResult(SenderState updatedSenderState, SenderState newSenderState, CiphertextS cS, Ciphertext cR, byte[] key, Kid kid) {</span>
<span class="fc" id="L902">            this.updatedSenderState = updatedSenderState;</span>
<span class="fc" id="L903">            this.newSenderState = newSenderState;</span>
<span class="fc" id="L904">            this.cS = cS;</span>
<span class="fc" id="L905">            this.cR = cR;</span>
<span class="fc" id="L906">            this.key = key;</span>
<span class="fc" id="L907">            this.kid = kid;</span>
<span class="fc" id="L908">        }</span>
    }

    // Ciphertext for sender/receiver add (procAddS/procAddR)
    public static class CiphertextS {
        public int i;
        public Map&lt;Integer, byte[]&gt; ekMap; // KEM encapsulation keys for each sender j
        public Set&lt;Integer&gt; memS;
        public Set&lt;Integer&gt; memR;
        public ToOperation to;

<span class="fc" id="L919">        public CiphertextS(int i, Map&lt;Integer, byte[]&gt; ekMap, Set&lt;Integer&gt; memS, Set&lt;Integer&gt; memR, ToOperation to) {</span>
<span class="fc" id="L920">            this.i = i;</span>
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">            this.ekMap = ekMap != null ? new HashMap&lt;&gt;(ekMap) : null;</span>
<span class="fc" id="L922">            this.memS = new HashSet&lt;&gt;(memS);</span>
<span class="fc" id="L923">            this.memR = new HashSet&lt;&gt;(memR);</span>
<span class="fc" id="L924">            this.to = to;</span>
<span class="fc" id="L925">        }</span>
    }
///////////////////////////////////////////////////
    // Proc add(st, ad, S, uid)
///////////////////////////////////////////////////
    public static AddSResult procAddS(SenderState st, byte[] ad, int uid) throws Exception {
        // Step 1: Update memS to include uid
<span class="fc" id="L932">        Set&lt;Integer&gt; memS = new HashSet&lt;&gt;(st.memS);</span>
<span class="fc" id="L933">        memS.add(uid);</span>
<span class="fc" id="L934">        ToOperation to = new ToOperation(OpType.ADD, TargetType.SENDER, uid);</span>

        // Step 2: Run enqOps
<span class="fc" id="L937">        EnqOpsResult enqResult = enqOps(st, memS, st.memR);</span>
<span class="fc" id="L938">        SenderState stAfterEnq = enqResult.updatedState;</span>
<span class="fc" id="L939">        Queue&lt;QueuedCiphertext&gt; cq = enqResult.cq;</span>

        // Step 3: Generate new signature keypair for the new sender
<span class="fc" id="L942">        com.myproject.signatureScheme.SignatureScheme.KeyPair newSigKeys = com.myproject.signatureScheme.SignatureScheme.gen();</span>
<span class="fc" id="L943">        byte[] svkuid = newSigKeys.getVk();</span>
<span class="fc" id="L944">        byte[] sskuid = newSigKeys.getSk();</span>

        // Step 4: Fork the BK tree for the new sender
<span class="fc" id="L947">        com.myproject.dynamicUBKem.UB_KEM.BKForkResult forkResult = com.myproject.dynamicUBKem.UB_KEM.fork(st.ek);</span>
        // ek1 = for current sender, ek2 = for new sender
<span class="fc" id="L949">        TreeEK ekuid = forkResult.ek2;</span>
<span class="fc" id="L950">        Object cM = forkResult.c;</span>

        // Step 5: Create new SenderState for the new sender
<span class="fc" id="L953">        SenderState stS = new SenderState(uid, memS, st.memR, ekuid, sskuid, svkuid, new byte[0], new LinkedList&lt;&gt;());</span>

        // Step 6: Prepare cS (placeholder, as per pseudocode)
<span class="fc" id="L956">        CiphertextS cS = new CiphertextS(st.i,  Collections.emptyMap(), Collections.emptySet(), Collections.emptySet(), to);</span>

        // Step 7: Call encaps with svkuid and cM
        // EncapsResult encapsResult = encaps(stAfterEnq, forkResult.ek1 , ad, cM, cq, svkuid, to);
        
<span class="fc" id="L961">        Map&lt;Integer, byte[]&gt; dkjRMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L962">        EncapsResult encapsResult = encaps(stAfterEnq, forkResult.ek1 , ad, cM, cq, svkuid, to, dkjRMap);</span>
        // EncapsResult encapsResult = encaps(stAfterEnq, st.ek, ad, cM, cq, svkuid, to);

        // Step 8: Return all results
<span class="fc" id="L966">        return new AddSResult(encapsResult.updatedState, stS, cS, encapsResult.ciphertext, encapsResult.key, encapsResult.kid);</span>
    }



    // Result class for procAddR
    public static class AddRResult {
        public SenderState updatedSenderState;
        public ReceiverEntry newReceiverEntry;
        public CiphertextS cS;
        public Ciphertext cR;
        public byte[] key;
        public Kid kid;

<span class="fc" id="L980">        public AddRResult(SenderState updatedSenderState, ReceiverEntry newReceiverEntry, CiphertextS cS, Ciphertext cR, byte[] key, Kid kid) {</span>
<span class="fc" id="L981">            this.updatedSenderState = updatedSenderState;</span>
<span class="fc" id="L982">            this.newReceiverEntry = newReceiverEntry;</span>
<span class="fc" id="L983">            this.cS = cS;</span>
<span class="fc" id="L984">            this.cR = cR;</span>
<span class="fc" id="L985">            this.key = key;</span>
<span class="fc" id="L986">            this.kid = kid;</span>
<span class="fc" id="L987">        }</span>
    }

//////////////////////////////////////////////
    // Implements: Proc add(st, ad, R, uid)
//////////////////////////////////////////////
    public static AddRResult procAddR(SenderState st, byte[] ad, int uid) throws Exception {
        // 46. (i,memS,memR, ek, ssk, svk, tr, ops) ← st
<span class="fc" id="L995">        int i = st.i;</span>
<span class="fc" id="L996">        Set&lt;Integer&gt; memS = new HashSet&lt;&gt;(st.memS);</span>
<span class="fc" id="L997">        Set&lt;Integer&gt; memR = new HashSet&lt;&gt;(st.memR);</span>
<span class="fc" id="L998">        TreeEK ek = st.ek;</span>
<span class="fc" id="L999">        byte[] ssk = st.ssk;</span>
<span class="fc" id="L1000">        byte[] svk = st.svk;</span>
<span class="fc" id="L1001">        byte[] tr = st.tr;</span>
<span class="fc" id="L1002">        Queue&lt;QueuedOperation&gt; ops = new LinkedList&lt;&gt;(st.ops);</span>

        // 47. memR∪←{uid}; to ← (A, R, uid)
<span class="fc" id="L1005">        memR.add(uid);</span>
<span class="fc" id="L1006">        ToOperation to = new ToOperation(OpType.ADD, TargetType.RECEIVER, uid);</span>

        // 48. cM, svkuid ← ϵ
<span class="fc" id="L1009">        Object cM = null;</span>
<span class="fc" id="L1010">        byte[] svkuid = new byte[0];</span>

        // 49. (st, cq) ← enq-ops(st,memS,memR)
<span class="fc" id="L1013">        EnqOpsResult enqResult = enqOps(st, memS, memR);</span>
<span class="fc" id="L1014">        SenderState stAfterEnq = enqResult.updatedState;</span>
<span class="fc" id="L1015">        Queue&lt;QueuedCiphertext&gt; cq = enqResult.cq;</span>

        // 50-54. For all j ∈ memS \ {i}: KEM keygen for senders and new receiver
<span class="fc" id="L1018">        Map&lt;Integer, byte[]&gt; ekjRMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1019">        Map&lt;Integer, byte[]&gt; dkjRMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1020">        Map&lt;Integer, SenderStateInReceiver&gt; Stuid = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L1021" title="All 2 branches covered.">        for (int j : memS) {</span>
<span class="fc bfc" id="L1022" title="All 2 branches covered.">            if (j == i) continue;</span>
            // 53. (ekjR, dkjR) ←$ K.gen
<span class="fc" id="L1024">            KEM.KeyPair kemKeyPair = KEM.gen();</span>
<span class="fc" id="L1025">            byte[] ekjR = kemKeyPair.getEk();</span>
<span class="fc" id="L1026">            byte[] dkjR = kemKeyPair.getDk();</span>
<span class="fc" id="L1027">            ekjRMap.put(j, ekjR);</span>
<span class="fc" id="L1028">            dkjRMap.put(j, dkjR);</span>
            // 54. Stuid[j] ← (memS,memR, dkjR, svk, ϵ) -- kemDkMap now used
<span class="fc" id="L1030">            Map&lt;Integer, TreeDk&gt; dkMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1031">            Map&lt;Integer, byte[]&gt; kemDkMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1032">            Map&lt;Integer, byte[]&gt; svkMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1033">            Map&lt;Integer, byte[]&gt; trMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1034">            dkMap.put(j, null); // No TreeDk for KEM receivers</span>
<span class="fc" id="L1035">            kemDkMap.put(j, dkjR);</span>
<span class="fc" id="L1036">            svkMap.put(j, svk);</span>
<span class="fc" id="L1037">            trMap.put(j, new byte[0]);</span>
<span class="fc" id="L1038">            Stuid.put(j, new SenderStateInReceiver(memS, memR, dkMap, kemDkMap, svkMap, trMap));</span>
<span class="fc" id="L1039">        }</span>

        // 55. (ek, dk, cM) ←$ BK.add(ek)
        // UB_KEM.BKAddResult bkAddResult = UB_KEM.add(ek);
<span class="fc" id="L1043">        UB_KEM.BKAddResult bkAddResult = UB_KEM.add(enqResult.updatedState.ek);</span>
<span class="fc" id="L1044">        ek = bkAddResult.ek;</span>
<span class="fc" id="L1045">        TreeDk dk = bkAddResult.dk;</span>
<span class="fc" id="L1046">        cM = bkAddResult.c;</span>

        // 56. Stuid[i] ← (memS,memR, dk, svk, tr)
<span class="fc" id="L1049">        Map&lt;Integer, TreeDk&gt; dkMapI = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1050">        Map&lt;Integer, byte[]&gt; kemDkMapI = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1051">        Map&lt;Integer, byte[]&gt; svkMapI = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1052">        Map&lt;Integer, byte[]&gt; trMapI = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1053">        dkMapI.put(i, dk);</span>
        // kemDkMapI is empty for i
<span class="fc" id="L1055">        svkMapI.put(i, svk);</span>
<span class="fc" id="L1056">        trMapI.put(i, tr);</span>
<span class="fc" id="L1057">        Stuid.put(i, new SenderStateInReceiver(memS, memR, dkMapI, kemDkMapI, svkMapI, trMapI));</span>

        // 57. stR ← Stuid
<span class="fc" id="L1060">        ReceiverEntry stR = new ReceiverEntry(true, Stuid);</span>

        // 58. cS ← (i, (ekjR)j∈memS\{i}, memS, memR, to)
<span class="fc" id="L1063">        CiphertextS cS = new CiphertextS(i, ekjRMap, new HashSet&lt;&gt;(memS), new HashSet&lt;&gt;(memR), to);</span>

        // 59. (st, cR, k, kid) ←$ encaps(st, ek, ad, cM, cq, svkuid, to)
        // EncapsResult encapsResult = encaps(stAfterEnq, ek, ad, cM, cq, svkuid, to);
<span class="fc" id="L1067">        EncapsResult encapsResult = encaps(stAfterEnq, ek, ad, cM, cq, svkuid, to, dkjRMap); </span>

        // 60. Return (st, stR, cS, cR, k, kid)
<span class="fc" id="L1070">        return new AddRResult(encapsResult.updatedState, stR, cS, encapsResult.ciphertext, encapsResult.key, encapsResult.kid);</span>
    }

///////////////////////////////////////////////////
// Proc proc(st, ad, c) 
///////////////////////////////////////////////////
    public static SenderState proc(SenderState st, byte[] ad, CiphertextS c) {
        // 38. If c = ⊥: Return st
<span class="pc bpc" id="L1078" title="1 of 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L1079">            return st;</span>
        }

        // 39. (i,memS,memR, ek, ssk, svk, tr, ops) ← st
<span class="fc" id="L1083">        int i = st.i;</span>
<span class="fc" id="L1084">        Set&lt;Integer&gt; memS = new HashSet&lt;&gt;(st.memS);</span>
<span class="fc" id="L1085">        Set&lt;Integer&gt; memR = new HashSet&lt;&gt;(st.memR);</span>
<span class="fc" id="L1086">        TreeEK ek = st.ek;</span>
<span class="fc" id="L1087">        byte[] ssk = st.ssk;</span>
<span class="fc" id="L1088">        byte[] svk = st.svk;</span>
<span class="fc" id="L1089">        byte[] tr = st.tr;</span>
<span class="fc" id="L1090">        Queue&lt;QueuedOperation&gt; ops = new LinkedList&lt;&gt;(st.ops);</span>

        // 40. c ← (j,ekMap,memjS,memjR, to)
<span class="fc" id="L1093">        int j = c.i;</span>
<span class="fc" id="L1094">        Map&lt;Integer, byte[]&gt; D = c.ekMap;</span>
<span class="fc" id="L1095">        Set&lt;Integer&gt; memjS = c.memS;</span>
<span class="fc" id="L1096">        Set&lt;Integer&gt; memjR = c.memR;</span>
<span class="fc" id="L1097">        ToOperation to = c.to;</span>

        // 41. (op, t, uid) ← to
<span class="fc" id="L1100">        OpType op = to.op;</span>
<span class="fc" id="L1101">        TargetType t = to.target;</span>
<span class="fc" id="L1102">        int uid = to.uid;</span>

        // 42. If (op, t, uid) = (R, S, i):
<span class="fc bfc" id="L1105" title="All 6 branches covered.">        if (op == OpType.REMOVE &amp;&amp; t == TargetType.SENDER &amp;&amp; uid == i) {</span>
            // 43. Return ⊥ // Calling sender was removed
<span class="fc" id="L1107">            return null;</span>
        }

        // 44. If i = j: Return st // No need to process c
<span class="pc bpc" id="L1111" title="1 of 2 branches missed.">        if (i == j) {</span>
<span class="nc" id="L1112">            return st;</span>
        }

        // 45. If op = A:
<span class="fc bfc" id="L1116" title="All 2 branches covered.">        if (op == OpType.ADD) {</span>
            // 46. If uid ∈ memt: Return st
<span class="pc bpc" id="L1118" title="2 of 8 branches missed.">            if ((t == TargetType.SENDER &amp;&amp; memS.contains(uid)) || (t == TargetType.RECEIVER &amp;&amp; memR.contains(uid))) {</span>
<span class="nc" id="L1119">                return st;</span>
            }
            // 47. memt∪←{uid}
<span class="fc bfc" id="L1122" title="All 2 branches covered.">            if (t == TargetType.SENDER) {</span>
<span class="fc" id="L1123">                memS.add(uid);</span>
            } else {
<span class="fc" id="L1125">                memR.add(uid);</span>
            }
            // 48. If t = R:
<span class="fc bfc" id="L1128" title="All 2 branches covered.">            if (t == TargetType.RECEIVER) {</span>
                // 49. (ekjR)j∈memS ← D
                // Do not assign D to ek; instead, pass the KEM key for uid if present
<span class="fc" id="L1131">                Diff diff = diff(st.memS, memjS, st.memR, memjR);</span>
                // ops.offer(new QueuedOperation(OpType.ADD, t, uid, diff, D != null ? D.get(uid) : null));
<span class="pc bpc" id="L1133" title="1 of 2 branches missed.">                ops.offer(new QueuedOperation(OpType.ADD, t, uid, diff, D != null ? D.get(i) : null));</span>
<span class="fc" id="L1134">            } else {</span>
                // 55. ops ← ops.enqueue(A, t, uid, ϵ, ϵ)
<span class="fc" id="L1136">                ops.offer(new QueuedOperation(OpType.ADD, t, uid, null, null));</span>
            }
        } else {
            // 57. If uid ̸∈ memt: Return st
<span class="pc bpc" id="L1140" title="2 of 8 branches missed.">            if ((t == TargetType.SENDER &amp;&amp; !memS.contains(uid)) || (t == TargetType.RECEIVER &amp;&amp; !memR.contains(uid))) {</span>
<span class="nc" id="L1141">                return st;</span>
            }
            // 58. memt ← memt \ {uid}
<span class="fc bfc" id="L1144" title="All 2 branches covered.">            if (t == TargetType.SENDER) {</span>
<span class="fc" id="L1145">                memS.remove(uid);</span>
            } else {
<span class="fc" id="L1147">                memR.remove(uid);</span>
            }
            // 59. ops ← ops.enqueue(R, t, uid, ϵ, ϵ)
<span class="fc" id="L1150">            ops.offer(new QueuedOperation(OpType.REMOVE, t, uid, null, null));</span>
        }
        // 60. st ← (i,memS,memR, ek, ssk, svk, tr, ops)
<span class="fc" id="L1153">        return new SenderState(i, memS, memR, ek, ssk, svk, tr, ops);</span>
    }



///////////////////////////////////////////////////
// Proc rmv(st, ad, t, uid)
///////////////////////////////////////////////////
    public static class RmvResult {
        public SenderState updatedSenderState;
        public CiphertextS cS;
        public Ciphertext cR;
        public byte[] key;
        public Kid kid;

<span class="fc" id="L1168">        public RmvResult(SenderState updatedSenderState, CiphertextS cS, Ciphertext cR, byte[] key, Kid kid) {</span>
<span class="fc" id="L1169">            this.updatedSenderState = updatedSenderState;</span>
<span class="fc" id="L1170">            this.cS = cS;</span>
<span class="fc" id="L1171">            this.cR = cR;</span>
<span class="fc" id="L1172">            this.key = key;</span>
<span class="fc" id="L1173">            this.kid = kid;</span>
<span class="fc" id="L1174">        }</span>
    }

    public static RmvResult procRmv(SenderState st, byte[] ad, TargetType t, int uid) throws Exception {
<span class="fc" id="L1178">        int i = st.i;</span>
<span class="fc" id="L1179">        Set&lt;Integer&gt; memS = new HashSet&lt;&gt;(st.memS);</span>
<span class="fc" id="L1180">        Set&lt;Integer&gt; memR = new HashSet&lt;&gt;(st.memR);</span>
<span class="fc" id="L1181">        TreeEK ek = st.ek;</span>
<span class="fc" id="L1182">        byte[] ssk = st.ssk;</span>
<span class="fc" id="L1183">        byte[] svk = st.svk;</span>
<span class="fc" id="L1184">        byte[] tr = st.tr;</span>
<span class="fc" id="L1185">        Queue&lt;QueuedOperation&gt; ops = new LinkedList&lt;&gt;(st.ops);</span>

        // 21. If uid ̸∈ memt: Return (st,⊥,⊥,⊥,⊥)
<span class="pc bpc" id="L1188" title="2 of 8 branches missed.">        if ((t == TargetType.SENDER &amp;&amp; !memS.contains(uid)) || (t == TargetType.RECEIVER &amp;&amp; !memR.contains(uid))) {</span>
<span class="nc" id="L1189">            return new RmvResult(st, null, null, null, null);</span>
        }

        // 22. If t = R: memt ← memt \ {uid}
<span class="fc bfc" id="L1193" title="All 2 branches covered.">        if (t == TargetType.RECEIVER) {</span>
<span class="fc" id="L1194">            memR.remove(uid);</span>
<span class="pc bpc" id="L1195" title="1 of 2 branches missed.">        } else if (t == TargetType.SENDER) {</span>
<span class="fc" id="L1196">            memS.remove(uid);</span>
        }

        // 23. to ← (R, t, uid); cM ← ϵ
<span class="fc" id="L1200">        ToOperation to = new ToOperation(OpType.REMOVE, t, uid);</span>
<span class="fc" id="L1201">        Object cM = null;</span>

        // 24. (st, cq) ← enq-ops(st,memS,memR)
<span class="fc" id="L1204">        EnqOpsResult enqResult = enqOps(st, memS, memR);</span>
<span class="fc" id="L1205">        SenderState stAfterEnq = enqResult.updatedState;</span>
<span class="fc" id="L1206">        Queue&lt;QueuedCiphertext&gt; cq = enqResult.cq;</span>

        // 25-26. If t = R: (ek, cM) ←$ BK.rmv(ek, uid)
<span class="fc bfc" id="L1209" title="All 2 branches covered.">        if (t == TargetType.RECEIVER) {</span>
<span class="fc" id="L1210">            UB_KEM.BKRemoveResult rmvResult = UB_KEM.rmv(ek, uid);</span>
<span class="fc" id="L1211">            ek = rmvResult.ek;</span>
<span class="fc" id="L1212">            cM = rmvResult.c;</span>
        }

        // 27. cS ← (i, ϵ, ϵ, ϵ, to)
<span class="fc" id="L1216">        CiphertextS cS = new CiphertextS(i, Collections.emptyMap(), Collections.emptySet(), Collections.emptySet(), to);</span>

        // 28. (st, cR, k, kid) ←$ encaps(st, ek, ad, cM, cq, ϵ, to)
        // EncapsResult encapsResult = encaps(stAfterEnq, ek, ad, cM, cq, new byte[0], to);

<span class="fc" id="L1221">        Map&lt;Integer, byte[]&gt; dkjRMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L1222">        EncapsResult encapsResult = encaps(stAfterEnq, ek, ad, cM, cq, new byte[0], to , dkjRMap);</span>

        // 29. Return (st, cS, cR, k, kid)
<span class="fc" id="L1225">        return new RmvResult(encapsResult.updatedState, cS, encapsResult.ciphertext, encapsResult.key, encapsResult.kid);</span>
    }



///////////////////////////////////////////////////

///////////////////////////////////////////////////
    public static byte[] concatenateByteArrays(Map&lt;Integer, byte[]&gt; byteMap)
    {
<span class="fc" id="L1235">        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream())</span>
        {
<span class="fc bfc" id="L1237" title="All 2 branches covered.">            for (byte[] byteArray : byteMap.values()) {</span>
<span class="fc" id="L1238">                outputStream.write(byteArray);</span>
<span class="fc" id="L1239">            }</span>
<span class="fc" id="L1240">            return outputStream.toByteArray();</span>
        }
<span class="nc" id="L1242">        catch (IOException e)</span>
        {
<span class="nc" id="L1244">            throw new RuntimeException(&quot;Error concatenating byte arrays&quot;, e);</span>
        }
    }


    private static byte[] serializeObject(Object obj)
    {
        /* May be there are more object types to cover */
<span class="fc bfc" id="L1252" title="All 2 branches covered.">        if (obj == null)</span>
        {
<span class="fc" id="L1254">            return new byte[0];</span>
        }
<span class="fc bfc" id="L1256" title="All 2 branches covered.">        else if (obj instanceof c_BKAdd)</span>
        {
            // System.out.println(&quot;Serializing object of type: &quot; + obj.getClass().getName());
            // System.out.println(&quot;Processing c_BKAdd&quot;);
<span class="fc" id="L1260">            c_BKAdd c = (c_BKAdd) obj;</span>

<span class="fc" id="L1262">            return concatAll(</span>
                new byte[]{c.t},
<span class="fc" id="L1264">                concatenateByteArrays(c.pkstarMap),</span>
<span class="fc" id="L1265">                concatenateByteArrays(c.pk_lMap)</span>
            );
        }
<span class="fc bfc" id="L1268" title="All 2 branches covered.">        else if (obj instanceof c_BKRemove)</span>
        {
            // System.out.println(&quot;Serializing object of type: &quot; + obj.getClass().getName());
            // System.out.println(&quot;Processing c_BKRemove&quot;);
<span class="fc" id="L1272">            c_BKRemove c = (c_BKRemove) obj;</span>

<span class="fc" id="L1274">            return concatAll(</span>
                new byte[]{c.t},
<span class="fc" id="L1276">                intToByteArray(c.i),</span>
<span class="fc" id="L1277">                concatenateByteArrays(c.pkStarMap),</span>
                c.pkCircle,
<span class="fc" id="L1279">                concatenateByteArrays(c.pkPrimeMap)</span>
            );
        }
<span class="pc bpc" id="L1282" title="1 of 2 branches missed.">        else if (obj instanceof c_BKFork)</span>
        {
<span class="fc" id="L1284">            c_BKFork c = (c_BKFork) obj;</span>

<span class="fc" id="L1286">            return concatAll(</span>
                new byte[]{c.t},
                c.pk
            );
        }
<span class="nc bnc" id="L1291" title="All 2 branches missed.">        else if (obj instanceof byte[])</span>
        {
<span class="nc" id="L1293">            return new byte[0]; </span>
        }
        // not sure what to return
        // return obj.toString().getBytes();
<span class="nc" id="L1297">        System.out.println(&quot;WARNING: Falling back to toString() for type: &quot; + obj.getClass().getName());</span>
        // return new byte[0];
<span class="nc" id="L1299">        throw new IllegalArgumentException(&quot;Unsupported ciphertext type: &quot; + obj.getClass().getName());</span>
    }
    
    private static byte[] serializeObject_Diff(Object obj)
    {
        /* May be there are more object types to cover */
<span class="pc bpc" id="L1305" title="1 of 2 branches missed.">        if (obj == null)</span>
        {
<span class="nc" id="L1307">            return new byte[0];</span>
        }
<span class="pc bpc" id="L1309" title="1 of 2 branches missed.">        else if (obj instanceof Diff)</span>
        {
            // System.out.println(&quot;Serializing object of type: &quot; + obj.getClass().getName());
<span class="fc" id="L1312">            Diff d = (Diff) obj;</span>

<span class="fc" id="L1314">            return concatAll(</span>
<span class="fc" id="L1315">                concatenateIntSet(d.senderAdd),</span>
<span class="fc" id="L1316">                concatenateIntSet(d.senderRemove),</span>
<span class="fc" id="L1317">                concatenateIntSet(d.receiverAdd),</span>
<span class="fc" id="L1318">                concatenateIntSet(d.receiverRemove)</span>
            );
        }
<span class="nc bnc" id="L1321" title="All 2 branches missed.">        else if (obj instanceof byte[])</span>
        {
            // should not occur here, as this is a diff serialization
<span class="nc" id="L1324">            System.out.println(&quot;Serializing byte[] object, returning empty array&quot;);</span>
<span class="nc" id="L1325">            return new byte[0]; </span>
        }

<span class="nc" id="L1328">        System.out.println(&quot;WARNING: Falling back to toString() for type: &quot; + obj.getClass().getName());</span>
<span class="nc" id="L1329">        throw new IllegalArgumentException(&quot;Unsupported ciphertext type: &quot; + obj.getClass().getName());</span>
    }

    private static byte[] concatenateIntSet(Set&lt;Integer&gt; set)
    {
<span class="fc" id="L1334">        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</span>
<span class="fc bfc" id="L1335" title="All 2 branches covered.">        for (Integer value : set) {</span>
<span class="fc" id="L1336">            byte[] bytes = intToByteArray(value);</span>
<span class="fc" id="L1337">            outputStream.write(bytes, 0, bytes.length);</span>
<span class="fc" id="L1338">        }</span>
<span class="fc" id="L1339">        return outputStream.toByteArray();</span>
    }

    // private static byte[] serializeTreeDk(TreeDk dk)
    // {
    //     Map&lt;Integer, byte[]&gt; skMap = dk.getDataSk();
    //     ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    //     for (byte[] value : skMap.values()) {
    //         if (value != null) {
    //             outputStream.write(value, 0, value.length);
    //         }
    //     }
    //     byte[] concatenated = outputStream.toByteArray();
    //     return concatenated;
    // }

    private static byte[] serializeTreeDk(TreeDk dk) {
<span class="fc" id="L1356">        ByteArrayOutputStream out = new ByteArrayOutputStream();</span>
        try {
            // Serialize leaf
<span class="fc" id="L1359">            out.write(intToByteArray(dk.getLeaf()));</span>

            // Serialize dataSk map
<span class="fc" id="L1362">            Map&lt;Integer, byte[]&gt; skMap = dk.getDataSk();</span>
<span class="fc" id="L1363">            out.write(intToByteArray(skMap.size()));</span>
<span class="fc bfc" id="L1364" title="All 2 branches covered.">            for (Map.Entry&lt;Integer, byte[]&gt; entry : skMap.entrySet()) {</span>
<span class="fc" id="L1365">                out.write(intToByteArray(entry.getKey()));</span>
<span class="fc" id="L1366">                byte[] value = entry.getValue();</span>
<span class="fc" id="L1367">                out.write(intToByteArray(value.length));</span>
<span class="fc" id="L1368">                out.write(value);</span>
<span class="fc" id="L1369">            }</span>

            // Serialize Tree object
<span class="fc" id="L1372">            Tree tree = dk.getTree();</span>
            // Serialize basic fields
<span class="fc" id="L1374">            out.write(intToByteArray(tree.getNumOfLeaf()));</span>
<span class="fc" id="L1375">            out.write(intToByteArray(tree.getSize()));</span>
<span class="fc" id="L1376">            out.write(intToByteArray(tree.getNodeIndexMax()));</span>
<span class="fc" id="L1377">            out.write(intToByteArray(tree.getLeafIndexMax()));</span>

            // Serialize nodeIndexes
<span class="fc" id="L1380">            out.write(intToByteArray(tree.getNodeIndexes().size()));</span>
<span class="fc bfc" id="L1381" title="All 2 branches covered.">            for (int idx : tree.getNodeIndexes()) {</span>
<span class="fc" id="L1382">                out.write(intToByteArray(idx));</span>
<span class="fc" id="L1383">            }</span>
            // Serialize leafIndexes
<span class="fc" id="L1385">            out.write(intToByteArray(tree.getLeafIndexes().size()));</span>
<span class="fc bfc" id="L1386" title="All 2 branches covered.">            for (int idx : tree.getLeafIndexes()) {</span>
<span class="fc" id="L1387">                out.write(intToByteArray(idx));</span>
<span class="fc" id="L1388">            }</span>

            // Serialize internalNode list
<span class="fc" id="L1391">            out.write(intToByteArray(tree.getNodesInternal().size()));</span>
<span class="fc bfc" id="L1392" title="All 2 branches covered.">            for (Tree.Node node : tree.getNodesInternal()) {</span>
<span class="fc" id="L1393">                out.write(intToByteArray(node.getNodeIndex()));</span>
<span class="fc" id="L1394">                out.write(intToByteArray(node.getRootnode()));</span>
<span class="fc" id="L1395">                out.write(intToByteArray(node.getChildLeftnode()));</span>
<span class="fc" id="L1396">                out.write(intToByteArray(node.getChildRightnode()));</span>
<span class="fc" id="L1397">                out.write(intToByteArray(node.getNodeLevel()));</span>
<span class="fc" id="L1398">                out.write(intToByteArray(node.getLeafIndex()));</span>

                // pk
<span class="fc" id="L1401">                byte[] pk = node.getPk();</span>
<span class="fc bfc" id="L1402" title="All 2 branches covered.">                out.write(intToByteArray(pk == null ? 0 : pk.length));</span>
<span class="fc bfc" id="L1403" title="All 2 branches covered.">                if (pk != null) out.write(pk);</span>

                // sk
<span class="fc" id="L1406">                byte[] sk = node.getSk();</span>
<span class="fc bfc" id="L1407" title="All 2 branches covered.">                out.write(intToByteArray(sk == null ? 0 : sk.length));</span>
<span class="fc bfc" id="L1408" title="All 2 branches covered.">                if (sk != null) out.write(sk);</span>

<span class="fc bfc" id="L1410" title="All 2 branches covered.">                out.write(node.isLeaf() ? 1 : 0);</span>
<span class="pc bpc" id="L1411" title="1 of 2 branches missed.">                out.write(node.isValidNode() ? 1 : 0);</span>
<span class="fc" id="L1412">            }</span>
<span class="nc" id="L1413">        } catch (Exception e) {</span>
<span class="nc" id="L1414">            throw new RuntimeException(&quot;Serialization failed&quot;, e);</span>
<span class="fc" id="L1415">        }</span>
<span class="fc" id="L1416">        return out.toByteArray();</span>
    }

    private static TreeDk deserializeTreeDk(byte[] bytes) {
<span class="fc" id="L1420">        int pos = 0;</span>

        // Helper
<span class="fc" id="L1423">        java.util.function.IntFunction&lt;Integer&gt; readInt = (start) -&gt; byteArrayToInt(java.util.Arrays.copyOfRange(bytes, start, start + 4));</span>

        // Deserialize leaf
<span class="fc" id="L1426">        int leaf = readInt.apply(pos); pos += 4;</span>

        // Deserialize dataSk map
<span class="fc" id="L1429">        int skMapSize = readInt.apply(pos); pos += 4;</span>
<span class="fc" id="L1430">        Map&lt;Integer, byte[]&gt; skMap = new java.util.HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L1431" title="All 2 branches covered.">        for (int i = 0; i &lt; skMapSize; i++) {</span>
<span class="fc" id="L1432">            int key = readInt.apply(pos); pos += 4;</span>
<span class="fc" id="L1433">            int valueLen = readInt.apply(pos); pos += 4;</span>
<span class="fc" id="L1434">            byte[] value = java.util.Arrays.copyOfRange(bytes, pos, pos + valueLen); pos += valueLen;</span>
<span class="fc" id="L1435">            skMap.put(key, value);</span>
        }

        // Deserialize Tree
<span class="fc" id="L1439">        int numLeaves = readInt.apply(pos); pos += 4;</span>
<span class="fc" id="L1440">        int treeSize = readInt.apply(pos); pos += 4;</span>
<span class="fc" id="L1441">        int nodeIndexMax = readInt.apply(pos); pos += 4;</span>
<span class="fc" id="L1442">        int leafIndexMax = readInt.apply(pos); pos += 4;</span>

<span class="fc" id="L1444">        int nodeIndexesSize = readInt.apply(pos); pos += 4;</span>
<span class="fc" id="L1445">        java.util.List&lt;Integer&gt; nodeIndexes = new java.util.ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1446" title="All 2 branches covered.">        for (int i = 0; i &lt; nodeIndexesSize; i++) {</span>
<span class="fc" id="L1447">            nodeIndexes.add(readInt.apply(pos)); pos += 4;</span>
        }
<span class="fc" id="L1449">        int leafIndexesSize = readInt.apply(pos); pos += 4;</span>
<span class="fc" id="L1450">        java.util.List&lt;Integer&gt; leafIndexes = new java.util.ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1451" title="All 2 branches covered.">        for (int i = 0; i &lt; leafIndexesSize; i++) {</span>
<span class="fc" id="L1452">            leafIndexes.add(readInt.apply(pos)); pos += 4;</span>
        }

<span class="fc" id="L1455">        int internalNodeSize = readInt.apply(pos); pos += 4;</span>
<span class="fc" id="L1456">        java.util.List&lt;Tree.Node&gt; internalNode = new java.util.ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L1457" title="All 2 branches covered.">        for (int i = 0; i &lt; internalNodeSize; i++) {</span>
<span class="fc" id="L1458">            Tree.Node.Builder builder = new Tree.Node.Builder();</span>
<span class="fc" id="L1459">            builder.setNodeIndex(readInt.apply(pos)); pos += 4;</span>
<span class="fc" id="L1460">            builder.setRootnode(readInt.apply(pos)); pos += 4;</span>
<span class="fc" id="L1461">            builder.setChildLeftnode(readInt.apply(pos)); pos += 4;</span>
<span class="fc" id="L1462">            builder.setChildRightnode(readInt.apply(pos)); pos += 4;</span>
<span class="fc" id="L1463">            builder.setNodeLevel(readInt.apply(pos)); pos += 4;</span>
<span class="fc" id="L1464">            builder.setLeafIndex(readInt.apply(pos)); pos += 4;</span>

<span class="fc" id="L1466">            int pkLen = readInt.apply(pos); pos += 4;</span>
<span class="fc bfc" id="L1467" title="All 2 branches covered.">            byte[] pk = pkLen &gt; 0 ? java.util.Arrays.copyOfRange(bytes, pos, pos + pkLen) : null; pos += pkLen;</span>
<span class="fc" id="L1468">            builder.setPk(pk);</span>

<span class="fc" id="L1470">            int skLen = readInt.apply(pos); pos += 4;</span>
<span class="fc bfc" id="L1471" title="All 2 branches covered.">            byte[] sk = skLen &gt; 0 ? java.util.Arrays.copyOfRange(bytes, pos, pos + skLen) : null; pos += skLen;</span>
<span class="fc" id="L1472">            builder.setSk(sk);</span>

<span class="fc bfc" id="L1474" title="All 2 branches covered.">            builder.setIsLeaf(bytes[pos++] == 1);</span>
<span class="pc bpc" id="L1475" title="1 of 2 branches missed.">            builder.setIsValidNode(bytes[pos++] == 1);</span>

<span class="fc" id="L1477">            internalNode.add(builder.build());</span>
        }

        // Construct Tree
<span class="fc" id="L1481">        Tree tree = new Tree();</span>
<span class="fc" id="L1482">        tree.setNumLeaves(numLeaves);</span>
<span class="fc" id="L1483">        tree.setTreeSize(treeSize);</span>
<span class="fc" id="L1484">        tree.setNodeIndexMax(nodeIndexMax);</span>
<span class="fc" id="L1485">        tree.setLeafIndexMax(leafIndexMax);</span>
<span class="fc" id="L1486">        tree.setNodeIndexes(nodeIndexes);</span>
<span class="fc" id="L1487">        tree.setLeafIndexes(leafIndexes);</span>
<span class="fc" id="L1488">        tree.setInternalNode(internalNode);</span>

<span class="fc" id="L1490">        return new TreeDk(tree, skMap, leaf);</span>
    }



    private static byte[] serializeQueue(Queue&lt;QueuedCiphertext&gt; cq) {
<span class="pc bpc" id="L1496" title="1 of 4 branches missed.">        if (cq == null || cq.isEmpty()) {</span>
<span class="fc" id="L1497">            return new byte[0];</span>
        }
<span class="fc" id="L1499">        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</span>
<span class="fc bfc" id="L1500" title="All 2 branches covered.">        for (QueuedCiphertext qc : cq) {</span>
<span class="fc" id="L1501">            byte[] opBytes = new byte[]{(byte) qc.op.ordinal()};</span>
<span class="fc" id="L1502">            byte[] tBytes = new byte[]{(byte) qc.t.ordinal()};</span>
<span class="fc" id="L1503">            byte[] uidBytes = intToByteArray(qc.uid);</span>
<span class="fc" id="L1504">            byte[] cMBytes = serializeObject(qc.cM);</span>
            byte[] cPBytes;
<span class="pc bpc" id="L1506" title="1 of 2 branches missed.">            if (qc.cP instanceof byte[]) {</span>
<span class="nc" id="L1507">                cPBytes = (byte[]) qc.cP;</span>
<span class="pc bpc" id="L1508" title="1 of 2 branches missed.">            } else if (qc.cP != null) {</span>
                // If cP is an Object[] (e.g., {c1, c2}), concatenate its byte[] elements
<span class="pc bpc" id="L1510" title="1 of 2 branches missed.">                if (qc.cP instanceof Object[]) {</span>
<span class="fc" id="L1511">                    Object[] arr = (Object[]) qc.cP;</span>
<span class="fc" id="L1512">                    ByteArrayOutputStream cPStream = new ByteArrayOutputStream();</span>
<span class="fc bfc" id="L1513" title="All 2 branches covered.">                    for (Object o : arr) {</span>
<span class="pc bpc" id="L1514" title="1 of 2 branches missed.">                        if (o instanceof byte[]) {</span>
<span class="fc" id="L1515">                            byte[] b = (byte[]) o;</span>
<span class="fc" id="L1516">                            cPStream.write(b, 0, b.length);</span>
                        }
                    }
<span class="fc" id="L1519">                    cPBytes = cPStream.toByteArray();</span>
<span class="fc" id="L1520">                } else {</span>
<span class="nc" id="L1521">                    cPBytes = serializeObject(qc.cP);</span>
                }
            } else {
<span class="nc" id="L1524">                cPBytes = new byte[0];</span>
            }
<span class="fc" id="L1526">            byte[] serialized = concatAll(opBytes, tBytes, uidBytes, cMBytes, cPBytes);</span>
            try {
<span class="fc" id="L1528">                outputStream.write(serialized);</span>
<span class="nc" id="L1529">            } catch (Exception e) {</span>
<span class="nc" id="L1530">                throw new RuntimeException(&quot;Error serializing QueuedCiphertext&quot;, e);</span>
<span class="fc" id="L1531">            }</span>
<span class="fc" id="L1532">        }</span>
<span class="fc" id="L1533">        return outputStream.toByteArray();</span>
    }

    private static byte[] serializeToOperation(ToOperation to) {
<span class="fc bfc" id="L1537" title="All 2 branches covered.">        if (to.isEmpty()) {</span>
<span class="fc" id="L1538">            return new byte[0];</span>
        }
<span class="fc" id="L1540">        return concatAll(new byte[]{(byte)(to.op.ordinal())}, </span>
<span class="fc" id="L1541">                        new byte[]{(byte)(to.target.ordinal())}, </span>
<span class="fc" id="L1542">                        intToByteArray(to.uid));</span>
    }

    private static byte[] serializeCiphertext(Ciphertext c) {
<span class="fc" id="L1546">        byte[] dkjRMapBytes = serializeDkjRMap(c.dkjRMap);</span>
<span class="fc" id="L1547">        return concatAll(intToByteArray(c.i), c.cPrime, serializeObject(c.cM), </span>
<span class="fc" id="L1548">                    serializeQueue(c.cq), c.svkStar, c.svkPrime, </span>
<span class="fc" id="L1549">                    serializeToOperation(c.to), c.signature, dkjRMapBytes);</span>
    }


    private static byte[] serializeDkjRMap(Map&lt;Integer, byte[]&gt; dkjRMap) {
<span class="pc bpc" id="L1554" title="1 of 4 branches missed.">        if (dkjRMap == null || dkjRMap.isEmpty()) return new byte[0];</span>
<span class="fc" id="L1555">        ByteArrayOutputStream out = new ByteArrayOutputStream();</span>
        try {
<span class="fc" id="L1557">            out.write(intToByteArray(dkjRMap.size()));</span>
<span class="fc bfc" id="L1558" title="All 2 branches covered.">            for (Map.Entry&lt;Integer, byte[]&gt; entry : dkjRMap.entrySet()) {</span>
<span class="fc" id="L1559">                out.write(intToByteArray(entry.getKey()));</span>
<span class="fc" id="L1560">                byte[] value = entry.getValue();</span>
<span class="fc" id="L1561">                out.write(intToByteArray(value.length));</span>
<span class="fc" id="L1562">                out.write(value);</span>
<span class="fc" id="L1563">            }</span>
<span class="nc" id="L1564">        } catch (Exception e) {</span>
<span class="nc" id="L1565">            throw new RuntimeException(&quot;Error serializing dkjRMap&quot;, e);</span>
<span class="fc" id="L1566">        }</span>
<span class="fc" id="L1567">        return out.toByteArray();</span>
    }

    private static byte[] concatAll(byte[]... arrays) {
<span class="fc" id="L1571">        int totalLength = 0;</span>
<span class="fc bfc" id="L1572" title="All 2 branches covered.">        for (byte[] array : arrays) {</span>
<span class="pc bpc" id="L1573" title="1 of 2 branches missed.">            if (array != null) {</span>
<span class="fc" id="L1574">                totalLength += array.length;</span>
            }
        }

<span class="fc" id="L1578">        byte[] result = new byte[totalLength];</span>
<span class="fc" id="L1579">        int currentIndex = 0;</span>
<span class="fc bfc" id="L1580" title="All 2 branches covered.">        for (byte[] array : arrays) {</span>
<span class="pc bpc" id="L1581" title="1 of 2 branches missed.">            if (array != null) {</span>
<span class="fc" id="L1582">                System.arraycopy(array, 0, result, currentIndex, array.length);</span>
<span class="fc" id="L1583">                currentIndex += array.length;</span>
            }
        }
<span class="fc" id="L1586">        return result;</span>
    }

    // private static byte[] xor(byte[] a, byte[] b) {
    //     if (a.length != b.length) {
    //         throw new IllegalArgumentException(&quot;Arrays must have same length&quot;);
    //     }
    //     byte[] result = new byte[a.length];
    //     for (int i = 0; i &lt; a.length; i++) {
    //         result[i] = (byte)(a[i] ^ b[i]);
    //     }
    //     return result;
    // }

    private static byte[] xor(byte[] a, byte[] b) {
<span class="fc" id="L1601">        int maxLen = Math.max(a.length, b.length);</span>
<span class="fc" id="L1602">        byte[] aFull = new byte[maxLen];</span>
<span class="fc" id="L1603">        byte[] bFull = new byte[maxLen];</span>

        // Repeat and fill aFull
<span class="fc bfc" id="L1606" title="All 2 branches covered.">        for (int i = 0; i &lt; maxLen; i++) {</span>
<span class="fc" id="L1607">            aFull[i] = a[i % a.length];</span>
        }
        // Repeat and fill bFull
<span class="fc bfc" id="L1610" title="All 2 branches covered.">        for (int i = 0; i &lt; maxLen; i++) {</span>
<span class="fc" id="L1611">            bFull[i] = b[i % b.length];</span>
        }

<span class="fc" id="L1614">        byte[] result = new byte[maxLen];</span>
<span class="fc bfc" id="L1615" title="All 2 branches covered.">        for (int i = 0; i &lt; maxLen; i++) {</span>
<span class="fc" id="L1616">            result[i] = (byte)(aFull[i] ^ bFull[i]);</span>
        }
<span class="fc" id="L1618">        return result;</span>
    }

    private static byte[] intToByteArray(int value) {
<span class="fc" id="L1622">        return new byte[] {</span>
            (byte)(value &gt;&gt;&gt; 24),
            (byte)(value &gt;&gt;&gt; 16),
            (byte)(value &gt;&gt;&gt; 8),
            (byte)(value)
        };
    }

    private static byte[] deriveKey(byte[] masterKey, byte[] info) {
<span class="fc" id="L1631">        byte[] salt = new byte[] {0x01, 0x02, 0x03, 0x04};</span>
<span class="fc" id="L1632">        HKDFBytesGenerator hkdf = new HKDFBytesGenerator(new SHA512Digest());</span>
<span class="fc" id="L1633">        HKDFParameters params = new HKDFParameters(masterKey, salt, info);</span>
<span class="fc" id="L1634">        hkdf.init(params);</span>

<span class="fc" id="L1636">        byte[] derivedKey = new byte[64]; // 64 bytes = 512-bit key</span>
<span class="fc" id="L1637">        hkdf.generateBytes(derivedKey, 0, derivedKey.length);</span>
<span class="fc" id="L1638">        return derivedKey;</span>
    }

    // Helper: get the length of serialized TreeDk (protocol-specific, set as needed)
    private static int getTreeDkSerializedLength() {
        // TODO: Return the correct length for your TreeDk serialization
        // For example, if TreeDk always serializes to 128 bytes:
        // return 128;
<span class="nc" id="L1646">        throw new UnsupportedOperationException(&quot;getTreeDkSerializedLength() not implemented&quot;);</span>
    }

    // // Helper: deserialize TreeDk from bytes
    // private static TreeDk deserializeTreeDk(byte[] bytes) {
    //     // TODO: Implement deserialization logic for TreeDk
    //     throw new UnsupportedOperationException(&quot;deserializeTreeDk() not implemented&quot;);
    // }


    // Helper: convert 4 bytes to int (big-endian)
    private static int byteArrayToInt(byte[] bytes) {
<span class="fc" id="L1658">        return   ((bytes[0] &amp; 0xFF) &lt;&lt; 24)</span>
               | ((bytes[1] &amp; 0xFF) &lt;&lt; 16)
               | ((bytes[2] &amp; 0xFF) &lt;&lt; 8)
               | (bytes[3] &amp; 0xFF);
    }


    // Helper: deserialize Diff from bytes
    private static Diff deserializeDiff(byte[] bytes) {
        // TODO: Implement deserialization logic for Diff
<span class="nc" id="L1668">        throw new UnsupportedOperationException(&quot;deserializeDiff() not implemented&quot;);</span>
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>